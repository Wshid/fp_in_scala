# [CHAP.07] 순수 함수적 병렬성
- 함수적 프로그래밍의 가정들이 **라이브러리 설계**에 어떤 영향을 미치는지
- 함수적 라이브러리 설계에 정답은 없음
  - 각자 `trade-off` 또는 장단점이 다른 `design choice`가 있음
- **병렬** 및 **비동기** 계산의 생성을 위한 **순수 함수적 라이브러리** 만들기
- 병렬적 프로그램에 내재하는 **복잡성**을
  - 순수 함수만으로 서술하기
- **치환 모형**을 이용하여 단순화 가능
  - 동시적 계산을 쉽게 할 수 있게 됨
- 계산의 **서술**이라는 관심사를
  - 계산의 실제 **실행**이라는 관심사와 분리하기
- 라이브러리 사용자가 라이브러리르 활용하여
  - 프로그램의 구체적인 실행 방식에 관한 세부사항과는 **격리된 수준**에서
  - 프로그램을 작성하기
  - 예시
    - `parMap`이라는 조합기를 개발
    - `f`를 한 컬렉션의 모든 요소에 동시 적용 가능
      ```scala
      val outputList = parMap(inputList)(f)
      ```
- 항상 **대수적 추론**에 역점을 두고
  - API를 특정 **법칙**들을 따르는, 하나의 **대수**(algebra)로 서술할 수 있다는 착안을 소개

## 7.1. 자료 형식과 함수의 선택
- 라이브러리 개발하기 : 병렬 계산을 생성할 수 있어야 함
- 병렬화할 계산 : 정수들의 합 구하기
  ```scala
  // foldLeft를 활용한 코드
  def sum(ints: Seq[Int]): Int =
    ints.foldLeft(0)((a,b) => a + b)
  ```
  - `Seq`에 `foldLeft` 메서드 존재
- 정수들은 순차적으로 접는 대신, `divide-and-conquer` 알고리즘 적용 가능

#### CODE.7.1. 분할정복 알고리즘을 이용한 목록 합산
```scala
// IndexedSeq; Vector와 비슷한 임의 접근 순차열의 상위 클래스
// 목록과는 달리, 순차령릉 특정 지점에서 두 부분으로 분할하는 효율적인 `splitAt` 메서드 제공
def sum(ints: IndexedSeq[Int]): Int =
  if (ints.size <= 1)
    ints.headOption getOrElse 0 // headOption, 모든 컬렉션에 정의되는 함수
  else {
    val (l, r) = ints.splitAt(ints.length/2) // splitAt 함수, 순차열을 반으로 나눔
    sum(l) + sum(r) // 재귀적으로 두 절반을 합치기
  }
```
- `splitAt`을 이용하여 **절반으로 분할**
  - 재귀적으로 두 절반을 합하여 결과를 합침
  - `foldLeft` 기반 구현과는 달리, 이 구현은 **병렬화** 가능
- 두 절반을 **병렬**로 합할 수 있다는 의미
- **병렬성**을 구현하기 위해
  - `Java.lang.Thread / Java.util.concurrent` 라이브러리 사용이 아닌,
  - 간단한 예제에서 영감을 얻어
    - 이상적인 API를 설계
    - 이후 구현으로 되돌아가는 접근방식

### 7.1.1. 병렬 계산을 위한 자료 형식 하나
- `sum(l) + sum(r)`
  - 두 절반에 대해 재귀적으로 `sum` 호출
  - 병렬 계산을 나타내는 자료 형식이, **하나의 결과**를 담아야 함
  - 그 결과는 의미 있는 형식 이어야 하며
    - 그 결과를 **추출하는 수단**도 갖추어야 함
- 결과를 담을 컨테이너 형식 `Par[A]`를 새로 invent
  - 이 형식에 필요한 함수
    - `def unit[A](a: => A): Par[A]`
      - 평가되지 않은 `A`를 받음
      - 개별적인 스레드에서 평가할 수 있는 계산을 반환
      - `unit`의 의미
        - 하나의 값을 감싸는 병렬성의 한 단위
    - `def get[A](a: Par[A]): A`
      - 병렬 계산에서 값을 추출

#### CODE.7.2. 새 커스텀 자료 형식을 이용하는 sum 함수
```scala
def sum(ints: IndexedSeq[Int]): Int =
  if (ints.size <= 1)
    ints headOption getOrElse 0
  else {
    val (l, r) = ints.splitAt(ints.length/2)
    val sumL: Par[Int] = Par.unit(sum(l)) // 왼쪽 절반 병렬 계산
    val sumR: Par[Int] Par.unit(sum(r)) // 오른쪽 절반 병렬 계산
    Par.get(sumL) + Par.get(sumR) // 두 결과를 합치기
  }
```
- 두 재귀적 `sum`호출을 `unit`으로 감싸고
  - 두 부분의 계산 결과를 `get`을 이용해 추출
- `unit`
  - 주어진 인수를 **개별적인 스레드**에서 즉시 평가 가능
  - 인수를 가지고 있다가, `get`이 호출되면 평가 가능
  - 병렬성의 이점을 위해서는
    - `unit`이 동시적 평가를 시작한 후, **즉시 반환**해야 함
- `unit`의 인수들이 평가를 동시에 시작한다면
  - `get`의 **참조 투명성**이 깨질 수 있음
  - 물론, `sumL`과 `sumR`을 해당 정의로 동시에 치환해보면, 이점이 명백해짐
  - 치환 결과가 나오긴 하나, 프로그램이 병렬로 실행되지 않음
    ```scala
    Par.get(Par.unit(sum(l))) + Par.get(Par.unit(sum(r)))
    ```
- `unit`이 자신의 인수를 **즉시 평가**하기 시작한다면,
  - 그 다음은 `get`이 그 평가의 완료를 기다리는 것
- `sumL`과 `sumR` 변수를 단순히 나열하면,
  - `+`의 양변은 **병렬로 실행되지 않음**
- 이는 `unit`에 한정적인 **부수 효과 존재**를 의미
  - 단, 그 부수 효과는 `get`에만 관련된 것
- 즉, `unit`은 **비동기 계산**을 나타내는 `Par[Int]`를 돌려줌
- `Par`를 `get`으로 넘겨주는 즉시,
  - `get`의 완료까지 실행이 차단된다는 **부수 효과**가 드러남
  - `get`을 호출하지 않거나, 호출을 ㅗ치대한 미루어야 함
- 비동기 계산들을 `그 완료를 기다리지 않고, 조합할 수 있어야 함`

#### 동시성 기본 수단을 직접 사용하는 것의 문제점
- `java.lang.Thread / Runnable`을 사용한다면?
  ```scala
  trait Runnable { def run: Unit}

  class Thread(r: Runnable) {
    def start: Unit // 개별 스레드에서 `r`의 실행을 시작
    def join: Unit // 호출한 스레드의 실행은 `r`의 실행이 끝날때까지 차단
  }
  ```
- 두 메서드 모두 **의미 있는 값을 돌려주지 않음**
- 즉, `Runnable`에서 어떤 정보를 얻으려면
  - 조사 가능한 어떤 상태를 변경하는 등의, **부수 효과**가 발생함
  - 합성 능력에 해가 됨
- `Runnable` 객체를 다룰 때는,
  - 항상 그 **내부 행동 방식**에 대해 무언가를 알아야 하기 때문에
  - 이를 `generic` 스타일로 조작 불가
- `Thread` 역시
  - **운영체제의 스레드**에 직접 대응된다는 단점 존재
- 바람직한 방식은,
  - **논리적 스레드**를 주어진 문제에 필요한 만큼, 얼마든지 생성하게 하고
  - 그것을 실제 `OS thread`에 대응시키는 것을 **나중에 처리**
- 이런 종류의 문제점을 `java.util.concurrent.Future / ExecutorService`로 처리 가능
  ```scala
  class ExecutorService {
    def submit[A](a: Callable[A]) : Future[A]
  }

  trait Future[A] {
    def get:A
  }
  ```
- 위와 같은 기본 수단이 **물리적 스레드**의 추상화에 도움이 되긴 하나,
  - 훨씬 낮은 수준의 추상
- `Future.get`을 호출하면
  - 호출한 스레드는 `ExecutorService`의 실행이 끝날때까지 차단됨
- 그리고 `API`는 `Future`를 **합성**하는 수단을 전혀 제공하지 않음
- 라이브러리 구현을 이 기본수단에 기초해서 구축할 수는 있음
- 그러나, 함수적 프로그램에서 직접 사용할 만한
  - 모듈적이고, 합성 능력이 있는 API는 제공하지 않음

### 7.1.2. 병렬 계산의 조합
- `unit`과 `get` 조합의 문제점을 어떻게 피할 수 있을지
- `get`을 호출하지 않는다면 
  - `sum` 함수는 반드시 `Par[Int]`를 돌려주어야 함
- 필요한 서명을 가진 함수들을 새로 작성
  ```scala
  def sum(ints: IndexedSeq[Int]): Par[Int] =
    if (ints.size <= 1)
      Par.unit(ints.headOption getOrlElse 0)
    else {
      val (l,r) = ints.splitAt(ints.length/2)
      Par.map2(sum(l), sum(r))(_ + _)
    }
  ```
- 재귀의 경우, `unit`을 호출하지 않음
- 이제는 `unit`이 인수가 **게으른 인수**인지도 명확하지 않음
  - 위 예제에서는 게으르게 받는다는 것이 별로 이득이 되지 않음
- `map2`의 경우, 인수를 게으르게 받아야할지
  - `map2`의 경우 계산의 양변에 **동등한 실행 기회**를 주어
  - 양변이 **병렬**로 계산되게 하는 것이 합당
    - `map2`의 인수들의 순서는 별로 중요하지 않음
    - 결합되는 두 계산이 독립적이며, 병렬로 실행될 수 있음을 나타내는 것이 중요
- 그러한 의미를 구현하려면? 어떤 선택이 필요할지
  - 간단한 검례(`test case`)로 `map2`의 인수가 엄격하게 평가된다고 할 때
  - `sum(IndexedSeq(1,2,3,4))`의 평가가 어떻게 진행되는지 생각

#### CODE.7.3. sum의 프로그램 추적
```scala
sum(IndexedSeq(1,2,3,4))

map2(
  sum(IndexedSeq(1,2)),
  sum(IndexedSeq(3,4,))(_ + _)
)

map2(
  map2(
    sum(IndexedSeq(1)),
    sum(IndexedSeq(2)))(_ + _),
  sum(IndexedSeq(3,4)))(_ + _)

map2(
  map2(
    unit(1),
    unit(2))(_ + _),
  sum(IndexedSeq(3,4)))(_ + _) 

map2(
  map2(
    unit(1),
    unit(2))(_ + _),
  sum(IndexedSeq(3)),
  sum(IndexedSeq(4)))(_ + _) 
```
- 이 추적에서 `sum(x)`을 평가하려면
  - 이전장에서 그랬듯, `x`를 `sum`의 정의에 대입해야 함
- `map2`는 엄격하므로, 스칼라는 그 인수들을
  - 왼쪽에서 오른쪽으로 평가
- `map2(sum(x),sum(y))(_+_)`를 만날 때마다
  - `sum(x)` 등을 재귀적으로 평가해야 함
- 이는 합산 트리의 **왼쪽 절반 전체**를 엄격하게 구축한 후에야
  - **오른쪽 절반**을 **엄격하게** 구축할 수 있다는 바람직하지 못한 결과로 이어짐
- `sum(IndexedSeq(1,2))`가 완전히 전개도니 이후,
  - `sum(IndexedSeq(3,4,))`의 평가가 시작
- 만일 `map2`의 인수들을 **병렬**로 평가한다면
  - (스레드 풀 등, 병렬성을 구현하는데 쓰이는 어떤 자원을 이용해서)
- 이는 계산의 **오른쪽 절반**을 시작하기도 전에
  - 계산의 **왼쪽 절반**이 실행되기 시작함을 의미
- `map2`를 엄격하게 유지하되, 그 실행이 즉시 시작되지 않게 한다면?
  - 이는 `map2`의 평가가 `즉시 시작되지 않음`은
  - `Par` 값이라는 것이 단지 **병렬**로 계산해야 할 것의
    - description을 구축하는 것을 의미
  - 그 서술을 평가하기 전까지는, 아무 일도 일어나지 않음
    - 평가 : `get`함수 들을 활용
- 만일 그러한 서술을 엄격하게 구축한다면,
  - 서술을 나타내는 객체가 **상당히 무거운 객체**가 될 것
- 앞의 프로그램 추적을 생각해 볼때, 그러한 서술은, 수행할 연산들의 **전체 트리**를 담아야 함
- 이 서술을 어떤 **자료 구조**에 담든
  - 그 자료구조는 원래의 **목록 자체**보다 더 많은 공간을 차지할 것
- `map2`를 게으르게 만들고,
  - 양변을 **병렬**로 즉시 실행하는 것이 더 나음
- 그러면 양변에 동등한 **실행 기회**를 부여하는 문제가 해결 됨

### 7.1.3. 명시적 분기
- `map2`의 두 인수를 **병렬**로 평가하는 것이 항상 바람직 할까?
- 예시
  ```scala
  Par.map2(Par.unit(1), Par.unit(1))(_ + _)
  ```
  - 결합하고자 하는 두 계산은 아주 빠르게 완료될 것이 자명하며,
  - 굳이 개별적인 **논리적 스레드**를 띄울 필요가 없음
- 그러나 현재의 `API`에는 이런 정보를 제공할 수 있는 **수단**이 갖추어 있지 않음
- 즉, 현재의 `API`는
  - 계산을 **주 스레드**로부터 분기한 시점에 관해 그리 **명료하지 않음**
- 프로그래머는 그러한 `forking`(분기)가 일하는 지점 또는
  - 시점을 구체적으로 지정할 수 없음
- 분기를 좀 더 **명시적**으로 만들면 어떨까?
  - 이를 위해 또 다른 함수 `fork`를 추가
  - 이 함수는 주어진 `Par`가 **개별 논리적 스레드**에서 실행되어야 함을 **명시적으로 지정**하는 용도로 쓰임
- `fork`가 적용된 `sum`의 예시
  ```scala
  def fork[A](a: => Par[A]): Par[A]

  def sum(ints: IndexedSeq[Int]): Par[Int] =
    if (ints.length <= 1)
      Par.unit(ints.headOption getOrElse 0)
    else {
      val (l,r) = ints.splitAt(ints.length/2)
      Par.map2(Par.fork(sum(l)), Par.fork(sum(r)))(_ + _)
    }
  ```
- `fork` 덕분에 `map2`를 엄격한 함수로 만들고
  - 인수들을 감싸는 것은 **프로그래머**의 뜻에 맡길 수 있게 됨
- `fork` 같은 함수는 **병렬 계산**들을
  - 너무 엄격하게 **인스턴스화**하는 문제를 해결해 주나,
  - 좀 더 근본적으로는 **병렬성**을 명시적으로 **프로그래머**의 통계하에 두는 역할을 함
- 여기서 관심사는 두 가지
  - 두 병렬 과제(task)의 결과들이 **결합**되어야 함을 지정하는 수단 필요
  - 특정 과제를 **비동기적**으로 수행할지 아닐지 선택하는 수단 필요
- 위 관심사를 분리한 덕분에
  - `map2`나 **기타 조합기**들에 **병렬성**에 관한
  - 그 어떤 **전역 방침**도 내장할 필요가 없음
- 만일 그런 **조합기**들이 **병렬성**에 관한 어떤 방침을 가져야 한다면,
  - 프로그래머는 어떤 것이 **최선의 방침**인지에 대한 어려운 결정을 내려야 함

#### `unit`이 엄격해야 하는지, 게을러야 하는지에 대한 문제
- `fork`가 있으니 `unit`을 엄격하게 만들어도, 표현력이 전혀 감소하지 않음
- 이 함수의 비엄격 버전(`lazyUnit`)은 `unit`과 `fork`로 간단히 구현 가능
  ```scala
  def unit[A](a: A): Par[A]
  def lazyUnit[A](a: A): Par[A] = fork(unit(a))
  ```
- `lazyUnit` 함수는
  - `unit`과 같은 **기본**(primitive) 조합기가 아니라 **파생된**(derived) 조합기의 간단한 예시
- `lazyUnit`은 다른 여산들을 이용해 정의 가능
- 나중에 `Par`의 구체적인 표현(representation)을 선택할 때
  - `lazyUnit`은 그 표현에 대해 아무것도 알 필요가 없음
- 단지 `Par`가 `Par`에 대해 정의된 연산 `fork`와 `unit`을 거치게 된 점만 알고 있음

#### fork, get의 책임
- `fork`는 인수들을 **개별 논리적 스레드**에서 평가되게 하는 수단
- 그런한 평가가 호출 **즉시** 일어나게 할 것인지,
  - 아니면 `get`과 같은 함수에 의해, 계산이 **강제**될 떄까지
  - 개별 논리적 스레드에서의 평가를 미룰 것인지는 아직 결정하지 않음 
- 평가가 `fork` 책임인지, `get`의 책임인지를 결정해야함
- 평가를 **적극적으로**(eagerly) 수행할 것인지, **게으르게** 수행할 것인지 선택한다고 말해도 될 것
- 독자가 `API`를 설계하면서
  - 한 함수에 의미를 부여할지 확실하지 않은 상황에 처해도,
  - 설계 공정을 계속 진행하는 것은 가능
- 서로 다른 의미의 선택에 따른 **장단점**이 나중에 가서야 명확해질 수 있음
- 이럴 시에 요령 한가지
  - 여러 의미를 가진 `fork`와 `get`의 구현에 **어떤 정보가 필요한가**를 생각해 보는 것

#### fork와 get의 구현에 필요한 정보
- `fork`가 자신의 인수를 즉시 **병렬**로 평가하기 시작한다면
  - 그 구현은 **스레드**를 생성하는 방법이나
  - 과제를 일종의 **스레드 풀**에 제출하는 방법을
  - 직접적으로든, 간접적으로든 알고 있어야 함
- 이는 **스레드 풀**(또는 병렬성을 구현하는 데 사용하는 어떤 자원)이
  - 반드시 접근 가능한(전역적으로) 자원이어야 하며,
  - `fork`를 호출하는 시점에서
    - 이미 적절히 **초기화**되어야 있음을 의미
- 그런 조건을 만족하려면,
  - 프로그램의 여러 부분에서 쓰이는 **병렬성 전략**을
  - 프로그래머가 임의로 제어할 수 있는 능력을 포기해야 함
- **병렬 과제**들의 실행을 위해 **전역 자원**을 두는 것이 근본적으로 잘못된 점은 아니나,
  - 구현이 무엇을 언제 사용할 것인지를 **프로그래머가 좀 더 세밀하게 제어**한다면, 더 좋음
    - e.g. 큰 app의 하위 시스템이 각자 다른 매개변수들로 설정된 스레드 풀을 유지하는 등
  - 스레드 생성과 실행 과제 제출의 책임을 `get`에 부여하는 것이 훨씬 좋음
- `fork`와 `get`의 구체적인 표현 방식을 알지 못한 상태로도,
  - 심지어 `Par`의 구체적인 표현을 결정하지 않고도
  - 이러한 결론에 도달 가능
- **병렬 과제**를 실제로 띄우는데 **필요한 정보**가 어떤 것인지를 비공식적으로 추론하고,
  - `Par`값들이 그러한 정보를 가진다면, 어떤 결과가 빚어질지 고찰했을 뿐
- 만일 `fork`가 그냥 인수의 평가를 뒤로 미루게 한다면,
  - `fork`는 **병렬성 구현**을 위한 매커니즘에 접근할 필요가 없음
- 그냥 평가되지 않은 `Par`인수를 받고
  - 그 인수에 동시에 평가가 필요한다는 점을 `표시`만 하면 됨
  - 이것이 `fork`의 의미라고 가정
- 이러한 모형에서 `Par` 자체는 **병렬성**의 구체적인 **구현 방법**을 알 필요가 없음
- `Par`는 나중에 `get` 함수 같은 무언가에 의해 **해석**될 **병렬 계산**에 관한 **서술**에 가까움
- 이는 `Par`를 나중에 준비되었을 때 조회(`get`)할 어떤 값을 담은 **컨테이너**라고 생각했던 것과는 다른 발생
- 이제는 **실행**이 가능한 일급 프로그램에 가까워짐
- 그런 취지에서 `get`함수의 이름을 `run`으로 바꾸고,
  - 병렬성이 실제로 구현되는 지점이 바로 `run`함수 임을 명명
- `run` 코드
  ```scala
  def run[A](a: Par[A]): A
  ``` 
- `Par`가 이제 **순수 자료구조**이므로,
  - `run`은 병렬성을 구현하는 **어떤 수단**을 갖추어야 한다
- `새 스레드`를 생성하거나, `과제`를 `스레드 풀`에 위임할 수도 있고
  - 그 밖에 다른 어떤 메커니즘을 사용할 수 있음

## 7.2. 표현의 선택
- Par를 위한 API 개요
  ```scala
  def unit[A](a: A): Par[A] // 즉시 평가되어서 결과 a를 산출하는 계산 생성
  def map2[A,B,C](a: Par[A], b: Par[B])(f: (A,B) => C): Par[C] // 두 병렬 계산의 결과들을 이항 함수로 조합
  def fork[A](a: => Par[A]):Par[A] // 이후 run이 동시적으로 평가할 계산임을 암시
  def lazyUnit[A](a: => A): Par[A] = fork(unit(a)) // run이 동시적으로 평가할 표현식 a를 감싼다
  def run[A](a: Par[A]): A // 주어진 Par를, fork의 요청에 따라 병렬 계산 수행, 이후 그 결과 값을 추출함으로써 완전히 평가
  ```
- 여러 함수에 느슨하게나마 의미가 부여됨
  - `unit`
    - 상수 값을 **병렬 계산**으로 승격(promote)
  - `map2`
    - 두 병렬 계산의 결과들을 **이항 함수**로 조합
  - `fork`
    - 주어진 인수가 **동시적으로 평가될 계산**임을 암시
    - 그 평가는 `run`에 강제 되어야 실제로 실행
  - `lazyUnit`
    - 평가되지 않은 인수를 `Par`로 감싸고
    - 그것을 **병렬 평가 대상**으로 표시
  - `run`
    - 계산을 실제로 실행해서 `Par`로부터 값을 추출
- `API 개요`를 만드는 과정에서 **추상 형식**들이 등장하는데,
  - 개요를 만드는 도중에도 그 형식들의 가능한 **표현**을 생각해보는 것은 당연한 일
- 적당한 표현을 고안할 수 있는지 시도하기
  - `run`이 어떤 방법으로든 **비동기적 과제**들을 실행해야 함
- 저수준 `API`를 직접 작성할 수도 있겠으나,
  - `java.util.concurrent.ExecutorService`가 이미 존재
- 이 클래스를 scala로 옮긴 코드
  ```scala
  class ExecutorService {
    def submit[A](a: Callable[A]): Future[A]
  }
  trait Callable[A] { def call: A } // 사실상 그냥 게으른 A
  trait Future[A] {
    def get: A
    def get(timeout: Long, unit: Timeunit): A
    def cancel(evenIfRunning: Boolean): Boolean
    def isDone: Boolean
    def isCancelled: Boolean
  }
  ```
- `ExecutorService::submit` 메서드는
  - 주어진 `Callable` 값(스칼라에서는 그냥 `submit`에 대한 게으른 인수)에 대응되는
  - 필요에 따라 **개별 스레드**에서 실행할 계산을 처리해주는
    - `Future` 객체를 돌려줌
- 계산의 결과는 `Future`의 `get`메서드로 얻을 수 있음
  - 이 메서드는 결과가 준비될 때까지 현재 스레드의 실행 차단
- `Future`는 또한 **계산의 취소**를 위한 **추가적인 기능**(일정 시간 동안 차단 후 예외를 던지는 등)도 제공
- `run` 함수가 `ExecutorService`에 접근할 수 있다고 가정하고,
  - 그것이 `Par`의 표현을 선택하는 데 어떤 통찰을 접근하는지 확인
    ```scala
    def run[A](s: ExecutorService)(a: Par[A]): A
    ```
- `Par[A]`의 표현으로 사용할 수 있는 가장 간단한 모형은 `ExecutorService => A`
- 이 표현을 선택한다면, `run`을 구현하기가 매우 쉬우나
  - 계산 완료까지의 `대기 시간`이나 `취소 여부`를 `run`의 호출자가 결정할 수 있게 하면 더 좋을 것
- 이를 위해 `Par[A]`를 `ExecutorService => Future[A]`로 두고
  - `run`은 `Future`를 돌려주게 변경
  ```scala
  type Par[A] = ExecutorService => Future[A]
  def run[A](s: ExecutorService)(a: Par[A]): Future[A] = a(s)
  ```
- `Par`가 `ExecutorService`를 필요로 하는 **하나의 함수**로 표현되었기 때문에
  - `Future`의 생성은 이 `ExecutorService`가 제공되기 전까지 일어나지 않음

## 7.3. API의 정련
- 지금까지의 작업 방식은 다소 **작위적**
- 실무에서는 API 설계와 **표현 선택 사이의 경계**가 지금만큼 명확하지 않음
- 표현에 대한 착안이 API 설계 개선에 도움이 되기도 하고,
  - API의 특성이 표현의 선택에 힌트가 되기도 함
- 두 관점 사이를 **유동적**으로 오가면서
  - 질문이 제기되면
  - 원형을 만들어 **실험**을 수행해보는 식으로 진행하는 것이 자연스러움
- `primitive`들을 정의하고, **적절한 정의**를 부여
- 지금까지 개발한 API 함수들을 구현하기
  - `Par`에 대한 표현이 정해졌기 때문에 그리 어렵지 않은 과정

#### CODE.7.5. Par의 기본적인 구현
```scala
object Par {
  // unit은 UnitFuture를 돌려주는 함수로 표현
  // UnitFuture는 Future의 단순한 구현으로, 단순 상수 값을 감싸기만 할 뿐
  // ExecutorService는 전혀 사용하지 않음
  // UnitFuture는 항상 완료 가능하며 취소는 불가능
  // UnitFuture::get 메서드는 이전에 주어진 상수 값을 돌려주기만 함
  def unit[A](a: A): Par[A] = (es: ExecutorService) => UnitFuture(a)

  private case class UnitFuture[A](get: A) extends Future[A] {
    def isDone = true
    def get(timeout: Long, units: TimeUnit) = get
    def isCancelled = false
    def cancel(evenIfRunning:Boolean): Boolean = false
  }

  // 이 API에서 병렬성 제어는 오직 `fork`함수만 담당한다는 설계상의 선택에 따라
  // map2는 f 호출을 논리적 스레드에서 평가하지 않음
  // f를 개별 스레드에서 평가하고 싶다면 fork(map2(a,b,)(f))를 사용하면 됨 
  def map2[A,B,C](a: Par[A], b: Par[B])(f: (A,B) => C): Par[C] =
    (es: ExecutorService) => {
      val af = a(es)
      val bf = b(es)
      UnitFuture(f(af.get, bf.get))
      // map2의 구현은 `만료 시간`을 지키지 않음
      // 이 구현은 ExecutorService를 두 Par 값에 전달하고
      // Future의 af와 bf의 결과들을 기다리고
      // 그것들을 f에 적용
      // 적용 결과를 UnitFuture로 감싼다
      // 만료 시간을 지키기 위해서는
      // af의 평가에 걸린 시간을 측정하고
      // bf의 평가에 걸린 시간에서
      // 그 시간을 빼는 식의, 새로운 Future 구현이 필요
    }
  
  def fork[A](a: => Par[A]): Par[A] =
    es => es.submit(new Callable[A] {
      def call = a(es).get
    })
  /**
    * 이것이 fork의 가장 간단하고 자연스러운 구현
    * 단 몇가지 문제점 존재
    * 외곽의 Callable은 `안쪽 과제가 완료될 때까지 차단`
    * 이러한 차단이, 스레드 풀의 한 스레드(또는 ExecutorService 내부에서 쓰이는 어떤 자원)을 점유하여
    * 이는 `잠재적 병렬성의 일부 소실`을 의미
    * 본질적으로 이 구현은, 한 스레드로 충분한 작업을 `두 스레드로 나누어 수행`
    * 이는 이 구현의 좀 더 심각한 문제점의 증상
    **/
}
```
- `Future` 인터페이스가 **순수 함수적**이지는 않음
  - 이는 이 예제 라이브러리의 사용자가
  - `Future`를 직접 다루게 하는 것이 **바람직하지 않은 이유**의 일부
- 중요한 것은, 이 `Future`의 메서드들이 **부수 효과**에 의존하긴 하지만
  - `Par API` 자체는 여전히 **순수**함
- `Future` 내부 동작 방식은, 오직 사용자가 `run`을 호출해서
  - 구현이 `ExecutorService`를 받게 되어야 드러남
- 구현이 언젠가는 **효과**들에 의존하긴 하지만,
  - 사용자는 항상 **순수한 인터페이스**로 프로그램을 짤 수 있음
- `API`가 순수하므로, 그 효과들은 사실상 **부수 효과가 아님**

#### 암묵적 변환을 이용한 중위 구문 추가
- `Par`가 실제 자료 형식이라면,
  - `map2` 같은 함수를 **클래스 본문**에 두고
  - `x.map2(y)(f)` 같은 **중위 구문**으로 호출 가능
    - `Stream`이나 `Option`에나 했던 것과 동일한 방식
- 그러나 `Par`는 형식 별칭이므로, 직접적으로 그렇게 할 수 없음
- `implicit conversion`을 이용해 **임의의 형식**에 중위 구문을 추가하는 요령이 존재
- 여기서는 다루지 않음

### 기존 조합기의 확장
- 구체적인 예시
  - 하나의 `List[Int]`를 산출하는 병렬 계산을 나타내는 
    - `Par[List[Int]]`가 있다고 가정
  - 이것을 **결과가 정렬된** `Par[List[Int]]`로 변환하고자 함
- 코드
  ```scala
  def sortPart(parList: Par[List[Int]]): Par[List[Int]]
  ```
- 물론 `Par`에 `run`을 적요하고, 결과 목록을 정렬하고
  - 정렬된 목록을 `unit`을 이요해서 다시 `Par`로 꾸밀 수 있음
- 우리는 `run`의 호출을 피하고자 함
- `unit`외에 `Par`의 값을 어떤 방식으로 조작할 수 있는 **조합기**는 `map2`뿐이라 가정
- 그렇다면, 만일 `ParList`를 `map2`의 양변 중 하나에 지정한다면,
  - `List` 내부에 접근해서 목록을 **졍렬**할 수 있음
- `map2`의 다른 변에는 아무것이나 넣어도 되므로, 그냥 `no-op`을 전달하기로 함
  ```scala
  def sortPar(parList: Part[List[Int]]): Par[List[Int]] =
    map2(parList, unit(()))((a, _) => a.sorted)
  ```

### 일반화
- `A => B` 형식의 **임의의 함수**를
  - `Par[A]`를 받고 `Par[B]`를 돌려주는 함수로 **승급**(`lift`)할 수 있음
- 코드
  ```scala
  def map2[A,B](pa: Par[A])(f: A => B): Par[B] =
    map2(pa, unit(()))((a, _) => f(a))

  // sortPar의 정의
  def sortPar(parList: Par[List[Int]]) = map(parList)(_.sorted)
  ```