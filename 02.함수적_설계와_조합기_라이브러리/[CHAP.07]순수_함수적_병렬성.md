# [CHAP.07] 순수 함수적 병렬성
- 함수적 프로그래밍의 가정들이 **라이브러리 설계**에 어떤 영향을 미치는지
- 함수적 라이브러리 설계에 정답은 없음
  - 각자 `trade-off` 또는 장단점이 다른 `design choice`가 있음
- **병렬** 및 **비동기** 계산의 생성을 위한 **순수 함수적 라이브러리** 만들기
- 병렬적 프로그램에 내재하는 **복잡성**을
  - 순수 함수만으로 서술하기
- **치환 모형**을 이용하여 단순화 가능
  - 동시적 계산을 쉽게 할 수 있게 됨
- 계산의 **서술**이라는 관심사를
  - 계산의 실제 **실행**이라는 관심사와 분리하기
- 라이브러리 사용자가 라이브러리르 활용하여
  - 프로그램의 구체적인 실행 방식에 관한 세부사항과는 **격리된 수준**에서
  - 프로그램을 작성하기
  - 예시
    - `parMap`이라는 조합기를 개발
    - `f`를 한 컬렉션의 모든 요소에 동시 적용 가능
      ```scala
      val outputList = parMap(inputList)(f)
      ```
- 항상 **대수적 추론**에 역점을 두고
  - API를 특정 **법칙**들을 따르는, 하나의 **대수**(algebra)로 서술할 수 있다는 착안을 소개

## 7.1. 자료 형식과 함수의 선택
- 라이브러리 개발하기 : 병렬 계산을 생성할 수 있어야 함
- 병렬화할 계산 : 정수들의 합 구하기
  ```scala
  // foldLeft를 활용한 코드
  def sum(ints: Seq[Int]): Int =
    ints.foldLeft(0)((a,b) => a + b)
  ```
  - `Seq`에 `foldLeft` 메서드 존재
- 정수들은 순차적으로 접는 대신, `divide-and-conquer` 알고리즘 적용 가능

#### CODE.7.1. 분할정복 알고리즘을 이용한 목록 합산
```scala
// IndexedSeq; Vector와 비슷한 임의 접근 순차열의 상위 클래스
// 목록과는 달리, 순차령릉 특정 지점에서 두 부분으로 분할하는 효율적인 `splitAt` 메서드 제공
def sum(ints: IndexedSeq[Int]): Int =
  if (ints.size <= 1)
    ints.headOption getOrElse 0 // headOption, 모든 컬렉션에 정의되는 함수
  else {
    val (l, r) = ints.splitAt(ints.length/2) // splitAt 함수, 순차열을 반으로 나눔
    sum(l) + sum(r) // 재귀적으로 두 절반을 합치기
  }
```
- `splitAt`을 이용하여 **절반으로 분할**
  - 재귀적으로 두 절반을 합하여 결과를 합침
  - `foldLeft` 기반 구현과는 달리, 이 구현은 **병렬화** 가능
- 두 절반을 **병렬**로 합할 수 있다는 의미
- **병렬성**을 구현하기 위해
  - `Java.lang.Thread / Java.util.concurrent` 라이브러리 사용이 아닌,
  - 간단한 예제에서 영감을 얻어
    - 이상적인 API를 설계
    - 이후 구현으로 되돌아가는 접근방식

### 7.1.1. 병렬 계산을 위한 자료 형식 하나
- `sum(l) + sum(r)`
  - 두 절반에 대해 재귀적으로 `sum` 호출
  - 병렬 계산을 나타내는 자료 형식이, **하나의 결과**를 담아야 함
  - 그 결과는 의미 있는 형식 이어야 하며
    - 그 결과를 **추출하는 수단**도 갖추어야 함
- 결과를 담을 컨테이너 형식 `Par[A]`를 새로 invent
  - 이 형식에 필요한 함수
    - `def unit[A](a: => A): Par[A]`
      - 평가되지 않은 `A`를 받음
      - 개별적인 스레드에서 평가할 수 있는 계산을 반환
      - `unit`의 의미
        - 하나의 값을 감싸는 병렬성의 한 단위
    - `def get[A](a: Par[A]): A`
      - 병렬 계산에서 값을 추출

#### CODE.7.2. 새 커스텀 자료 형식을 이용하는 sum 함수
```scala
def sum(ints: IndexedSeq[Int]): Int =
  if (ints.size <= 1)
    ints headOption getOrElse 0
  else {
    val (l, r) = ints.splitAt(ints.length/2)
    val sumL: Par[Int] = Par.unit(sum(l)) // 왼쪽 절반 병렬 계산
    val sumR: Par[Int] Par.unit(sum(r)) // 오른쪽 절반 병렬 계산
    Par.get(sumL) + Par.get(sumR) // 두 결과를 합치기
  }
```
- 두 재귀적 `sum`호출을 `unit`으로 감싸고
  - 두 부분의 계산 결과를 `get`을 이용해 추출
- `unit`
  - 주어진 인수를 **개별적인 스레드**에서 즉시 평가 가능
  - 인수를 가지고 있다가, `get`이 호출되면 평가 가능
  - 병렬성의 이점을 위해서는
    - `unit`이 동시적 평가를 시작한 후, **즉시 반환**해야 함
- `unit`의 인수들이 평가를 동시에 시작한다면
  - `get`의 **참조 투명성**이 깨질 수 있음
  - 물론, `sumL`과 `sumR`을 해당 정의로 동시에 치환해보면, 이점이 명백해짐
  - 치환 결과가 나오긴 하나, 프로그램이 병렬로 실행되지 않음
    ```scala
    Par.get(Par.unit(sum(l))) + Par.get(Par.unit(sum(r)))
    ```
- `unit`이 자신의 인수를 **즉시 평가**하기 시작한다면,
  - 그 다음은 `get`이 그 평가의 완료를 기다리는 것
- `sumL`과 `sumR` 변수를 단순히 나열하면,
  - `+`의 양변은 **병렬로 실행되지 않음**
- 이는 `unit`에 한정적인 **부수 효과 존재**를 의미
  - 단, 그 부수 효과는 `get`에만 관련된 것
- 즉, `unit`은 **비동기 계산**을 나타내는 `Par[Int]`를 돌려줌
- `Par`를 `get`으로 넘겨주는 즉시,
  - `get`의 완료까지 실행이 차단된다는 **부수 효과**가 드러남
  - `get`을 호출하지 않거나, 호출을 ㅗ치대한 미루어야 함
- 비동기 계산들을 `그 완료를 기다리지 않고, 조합할 수 있어야 함`

#### 동시성 기본 수단을 직접 사용하는 것의 문제점
- `java.lang.Thread / Runnable`을 사용한다면?
  ```scala
  trait Runnable { def run: Unit}

  class Thread(r: Runnable) {
    def start: Unit // 개별 스레드에서 `r`의 실행을 시작
    def join: Unit // 호출한 스레드의 실행은 `r`의 실행이 끝날때까지 차단
  }
  ```
- 두 메서드 모두 **의미 있는 값을 돌려주지 않음**
- 즉, `Runnable`에서 어떤 정보를 얻으려면
  - 조사 가능한 어떤 상태를 변경하는 등의, **부수 효과**가 발생함
  - 합성 능력에 해가 됨
- `Runnable` 객체를 다룰 때는,
  - 항상 그 **내부 행동 방식**에 대해 무언가를 알아야 하기 때문에
  - 이를 `generic` 스타일로 조작 불가
- `Thread` 역시
  - **운영체제의 스레드**에 직접 대응된다는 단점 존재
- 바람직한 방식은,
  - **논리적 스레드**를 주어진 문제에 필요한 만큼, 얼마든지 생성하게 하고
  - 그것을 실제 `OS thread`에 대응시키는 것을 **나중에 처리**
- 이런 종류의 문제점을 `java.util.concurrent.Future / ExecutorService`로 처리 가능
  ```scala
  class ExecutorService {
    def submit[A](a: Callable[A]) : Future[A]
  }

  trait Future[A] {
    def get:A
  }
  ```
- 위와 같은 기본 수단이 **물리적 스레드**의 추상화에 도움이 되긴 하나,
  - 훨씬 낮은 수준의 추상
- `Future.get`을 호출하면
  - 호출한 스레드는 `ExecutorService`의 실행이 끝날때까지 차단됨
- 그리고 `API`는 `Future`를 **합성**하는 수단을 전혀 제공하지 않음
- 라이브러리 구현을 이 기본수단에 기초해서 구축할 수는 있음
- 그러나, 함수적 프로그램에서 직접 사용할 만한
  - 모듈적이고, 합성 능력이 있는 API는 제공하지 않음

### 7.1.2. 병렬 계산의 조합
- `unit`과 `get` 조합의 문제점을 어떻게 피할 수 있을지
- `get`을 호출하지 않는다면 
  - `sum` 함수는 반드시 `Par[Int]`를 돌려주어야 함
- 필요한 서명을 가진 함수들을 새로 작성
  ```scala
  def sum(ints: IndexedSeq[Int]): Par[Int] =
    if (ints.size <= 1)
      Par.unit(ints.headOption getOrlElse 0)
    else {
      val (l,r) = ints.splitAt(ints.length/2)
      Par.map2(sum(l), sum(r))(_ + _)
    }
  ```
- 재귀의 경우, `unit`을 호출하지 않음
- 이제는 `unit`이 인수가 **게으른 인수**인지도 명확하지 않음
  - 위 예제에서는 게으르게 받는다는 것이 별로 이득이 되지 않음
- `map2`의 경우, 인수를 게으르게 받아야할지
  - `map2`의 경우 계산의 양변에 **동등한 실행 기회**를 주어
  - 양변이 **병렬**로 계산되게 하는 것이 합당
    - `map2`의 인수들의 순서는 별로 중요하지 않음
    - 결합되는 두 계산이 독립적이며, 병렬로 실행될 수 있음을 나타내는 것이 중요
- 그러한 의미를 구현하려면? 어떤 선택이 필요할지
  - 간단한 검례(`test case`)로 `map2`의 인수가 엄격하게 평가된다고 할 때
  - `sum(IndexedSeq(1,2,3,4))`의 평가가 어떻게 진행되는지 생각

#### CODE.7.3. sum의 프로그램 추적
```scala
sum(IndexedSeq(1,2,3,4))

map2(
  sum(IndexedSeq(1,2)),
  sum(IndexedSeq(3,4,))(_ + _)
)

map2(
  map2(
    sum(IndexedSeq(1)),
    sum(IndexedSeq(2)))(_ + _),
  sum(IndexedSeq(3,4)))(_ + _)

map2(
  map2(
    unit(1),
    unit(2))(_ + _),
  sum(IndexedSeq(3,4)))(_ + _) 

map2(
  map2(
    unit(1),
    unit(2))(_ + _),
  sum(IndexedSeq(3)),
  sum(IndexedSeq(4)))(_ + _) 
```
- 이 추적에서 `sum(x)`을 평가하려면
  - 이전장에서 그랬듯, `x`를 `sum`의 정의에 대입해야 함
- `map2`는 엄격하므로, 스칼라는 그 인수들을
  - 왼쪽에서 오른쪽으로 평가
- `map2(sum(x),sum(y))(_+_)`를 만날 때마다
  - `sum(x)` 등을 재귀적으로 평가해야 함
- 이는 합산 트리의 **왼쪽 절반 전체**를 엄격하게 구축한 후에야
  - **오른쪽 절반**을 **엄격하게** 구축할 수 있다는 바람직하지 못한 결과로 이어짐
- `sum(IndexedSeq(1,2))`가 완전히 전개도니 이후,
  - `sum(IndexedSeq(3,4,))`의 평가가 시작
- 만일 `map2`의 인수들을 **병렬**로 평가한다면
  - (스레드 풀 등, 병렬성을 구현하는데 쓰이는 어떤 자원을 이용해서)
- 이는 계산의 **오른쪽 절반**을 시작하기도 전에
  - 계산의 **왼쪽 절반**이 실행되기 시작함을 의미
- `map2`를 엄격하게 유지하되, 그 실행이 즉시 시작되지 않게 한다면?
  - 이는 `map2`의 평가가 `즉시 시작되지 않음`은
  - `Par` 값이라는 것이 단지 **병렬**로 계산해야 할 것의
    - description을 구축하는 것을 의미
  - 그 서술을 평가하기 전까지는, 아무 일도 일어나지 않음
    - 평가 : `get`함수 들을 활용
- 만일 그러한 서술을 엄격하게 구축한다면,
  - 서술을 나타내는 객체가 **상당히 무거운 객체**가 될 것
- 앞의 프로그램 추적을 생각해 볼때, 그러한 서술은, 수행할 연산들의 **전체 트리**를 담아야 함
- 이 서술을 어떤 **자료 구조**에 담든
  - 그 자료구조는 원래의 **목록 자체**보다 더 많은 공간을 차지할 것
- `map2`를 게으르게 만들고,
  - 양변을 **병렬**로 즉시 실행하는 것이 더 나음
- 그러면 양변에 동등한 **실행 기회**를 부여하는 문제가 해결 됨

### 7.1.3. 명시적 분기
- `map2`의 두 인수를 **병렬**로 평가하는 것이 항상 바람직 할까?
- 예시
  ```scala
  Par.map2(Par.unit(1), Par.unit(1))(_ + _)
  ```
  - 결합하고자 하는 두 계산은 아주 빠르게 완료될 것이 자명하며,
  - 굳이 개별적인 **논리적 스레드**를 띄울 필요가 없음
- 그러나 현재의 `API`에는 이런 정보를 제공할 수 있는 **수단**이 갖추어 있지 않음
- 즉, 현재의 `API`는
  - 계산을 **주 스레드**로부터 분기한 시점에 관해 그리 **명료하지 않음**
- 프로그래머는 그러한 `forking`(분기)가 일하는 지점 또는
  - 시점을 구체적으로 지정할 수 없음
- 분기를 좀 더 **명시적**으로 만들면 어떨까?
  - 이를 위해 또 다른 함수 `fork`를 추가
  - 이 함수는 주어진 `Par`가 **개별 논리적 스레드**에서 실행되어야 함을 **명시적으로 지정**하는 용도로 쓰임
- `fork`가 적용된 `sum`의 예시
  ```scala
  def fork[A](a: => Par[A]): Par[A]

  def sum(ints: IndexedSeq[Int]): Par[Int] =
    if (ints.length <= 1)
      Par.unit(ints.headOption getOrElse 0)
    else {
      val (l,r) = ints.splitAt(ints.length/2)
      Par.map2(Par.fork(sum(l)), Par.fork(sum(r)))(_ + _)
    }
  ```
- `fork` 덕분에 `map2`를 엄격한 함수로 만들고
  - 인수들을 감싸는 것은 **프로그래머**의 뜻에 맡길 수 있게 됨
- `fork` 같은 함수는 **병렬 계산**들을
  - 너무 엄격하게 **인스턴스화**하는 문제를 해결해 주나,
  - 좀 더 근본적으로는 **병렬성**을 명시적으로 **프로그래머**의 통계하에 두는 역할을 함
- 여기서 관심사는 두 가지
  - 두 병렬 과제(task)의 결과들이 **결합**되어야 함을 지정하는 수단 필요
  - 특정 과제를 **비동기적**으로 수행할지 아닐지 선택하는 수단 필요
- 위 관심사를 분리한 덕분에
  - `map2`나 **기타 조합기**들에 **병렬성**에 관한
  - 그 어떤 **전역 방침**도 내장할 필요가 없음
- 만일 그런 **조합기**들이 **병렬성**에 관한 어떤 방침을 가져야 한다면,
  - 프로그래머는 어떤 것이 **최선의 방침**인지에 대한 어려운 결정을 내려야 함

#### `unit`이 엄격해야 하는지, 게을러야 하는지에 대한 문제
- `fork`가 있으니 `unit`을 엄격하게 만들어도, 표현력이 전혀 감소하지 않음
- 이 함수의 비엄격 버전(`lazyUnit`)은 `unit`과 `fork`로 간단히 구현 가능
  ```scala
  def unit[A](a: A): Par[A]
  def lazyUnit[A](a: A): Par[A] = fork(unit(a))
  ```
- `lazyUnit` 함수는
  - `unit`과 같은 **기본**(primitive) 조합기가 아니라 **파생된**(derived) 조합기의 간단한 예시
- `lazyUnit`은 다른 여산들을 이용해 정의 가능
- 나중에 `Par`의 구체적인 표현(representation)을 선택할 때
  - `lazyUnit`은 그 표현에 대해 아무것도 알 필요가 없음
- 단지 `Par`가 `Par`에 대해 정의된 연산 `fork`와 `unit`을 거치게 된 점만 알고 있음

#### fork, get의 책임
- `fork`는 인수들을 **개별 논리적 스레드**에서 평가되게 하는 수단
- 그런한 평가가 호출 **즉시** 일어나게 할 것인지,
  - 아니면 `get`과 같은 함수에 의해, 계산이 **강제**될 떄까지
  - 개별 논리적 스레드에서의 평가를 미룰 것인지는 아직 결정하지 않음 
- 평가가 `fork` 책임인지, `get`의 책임인지를 결정해야함
- 평가를 **적극적으로**(eagerly) 수행할 것인지, **게으르게** 수행할 것인지 선택한다고 말해도 될 것
- 독자가 `API`를 설계하면서
  - 한 함수에 의미를 부여할지 확실하지 않은 상황에 처해도,
  - 설계 공정을 계속 진행하는 것은 가능
- 서로 다른 의미의 선택에 따른 **장단점**이 나중에 가서야 명확해질 수 있음
- 이럴 시에 요령 한가지
  - 여러 의미를 가진 `fork`와 `get`의 구현에 **어떤 정보가 필요한가**를 생각해 보는 것

#### fork와 get의 구현에 필요한 정보
- `fork`가 자신의 인수를 즉시 **병렬**로 평가하기 시작한다면
  - 그 구현은 **스레드**를 생성하는 방법이나
  - 과제를 일종의 **스레드 풀**에 제출하는 방법을
  - 직접적으로든, 간접적으로든 알고 있어야 함
- 이는 **스레드 풀**(또는 병렬성을 구현하는 데 사용하는 어떤 자원)이
  - 반드시 접근 가능한(전역적으로) 자원이어야 하며,
  - `fork`를 호출하는 시점에서
    - 이미 적절히 **초기화**되어야 있음을 의미
- 그런 조건을 만족하려면,
  - 프로그램의 여러 부분에서 쓰이는 **병렬성 전략**을
  - 프로그래머가 임의로 제어할 수 있는 능력을 포기해야 함
- **병렬 과제**들의 실행을 위해 **전역 자원**을 두는 것이 근본적으로 잘못된 점은 아니나,
  - 구현이 무엇을 언제 사용할 것인지를 **프로그래머가 좀 더 세밀하게 제어**한다면, 더 좋음
    - e.g. 큰 app의 하위 시스템이 각자 다른 매개변수들로 설정된 스레드 풀을 유지하는 등
  - 스레드 생성과 실행 과제 제출의 책임을 `get`에 부여하는 것이 훨씬 좋음
- `fork`와 `get`의 구체적인 표현 방식을 알지 못한 상태로도,
  - 심지어 `Par`의 구체적인 표현을 결정하지 않고도
  - 이러한 결론에 도달 가능
- **병렬 과제**를 실제로 띄우는데 **필요한 정보**가 어떤 것인지를 비공식적으로 추론하고,
  - `Par`값들이 그러한 정보를 가진다면, 어떤 결과가 빚어질지 고찰했을 뿐
- 만일 `fork`가 그냥 인수의 평가를 뒤로 미루게 한다면,
  - `fork`는 **병렬성 구현**을 위한 매커니즘에 접근할 필요가 없음
- 그냥 평가되지 않은 `Par`인수를 받고
  - 그 인수에 동시에 평가가 필요한다는 점을 `표시`만 하면 됨
  - 이것이 `fork`의 의미라고 가정
- 이러한 모형에서 `Par` 자체는 **병렬성**의 구체적인 **구현 방법**을 알 필요가 없음
- `Par`는 나중에 `get` 함수 같은 무언가에 의해 **해석**될 **병렬 계산**에 관한 **서술**에 가까움
- 이는 `Par`를 나중에 준비되었을 때 조회(`get`)할 어떤 값을 담은 **컨테이너**라고 생각했던 것과는 다른 발생
- 이제는 **실행**이 가능한 일급 프로그램에 가까워짐
- 그런 취지에서 `get`함수의 이름을 `run`으로 바꾸고,
  - 병렬성이 실제로 구현되는 지점이 바로 `run`함수 임을 명명
- `run` 코드
  ```scala
  def run[A](a: Par[A]): A
  ``` 
- `Par`가 이제 **순수 자료구조**이므로,
  - `run`은 병렬성을 구현하는 **어떤 수단**을 갖추어야 한다
- `새 스레드`를 생성하거나, `과제`를 `스레드 풀`에 위임할 수도 있고
  - 그 밖에 다른 어떤 메커니즘을 사용할 수 있음

## 7.2. 표현의 선택
- Par를 위한 API 개요
  ```scala
  def unit[A](a: A): Par[A] // 즉시 평가되어서 결과 a를 산출하는 계산 생성
  def map2[A,B,C](a: Par[A], b: Par[B])(f: (A,B) => C): Par[C] // 두 병렬 계산의 결과들을 이항 함수로 조합
  def fork[A](a: => Par[A]):Par[A] // 이후 run이 동시적으로 평가할 계산임을 암시
  def lazyUnit[A](a: => A): Par[A] = fork(unit(a)) // run이 동시적으로 평가할 표현식 a를 감싼다
  def run[A](a: Par[A]): A // 주어진 Par를, fork의 요청에 따라 병렬 계산 수행, 이후 그 결과 값을 추출함으로써 완전히 평가
  ```
- 여러 함수에 느슨하게나마 의미가 부여됨
  - `unit`
    - 상수 값을 **병렬 계산**으로 승격(promote)
  - `map2`
    - 두 병렬 계산의 결과들을 **이항 함수**로 조합
  - `fork`
    - 주어진 인수가 **동시적으로 평가될 계산**임을 암시
    - 그 평가는 `run`에 강제 되어야 실제로 실행
  - `lazyUnit`
    - 평가되지 않은 인수를 `Par`로 감싸고
    - 그것을 **병렬 평가 대상**으로 표시
  - `run`
    - 계산을 실제로 실행해서 `Par`로부터 값을 추출
- `API 개요`를 만드는 과정에서 **추상 형식**들이 등장하는데,
  - 개요를 만드는 도중에도 그 형식들의 가능한 **표현**을 생각해보는 것은 당연한 일
- 적당한 표현을 고안할 수 있는지 시도하기
  - `run`이 어떤 방법으로든 **비동기적 과제**들을 실행해야 함
- 저수준 `API`를 직접 작성할 수도 있겠으나,
  - `java.util.concurrent.ExecutorService`가 이미 존재
- 이 클래스를 scala로 옮긴 코드
  ```scala
  class ExecutorService {
    def submit[A](a: Callable[A]): Future[A]
  }
  trait Callable[A] { def call: A } // 사실상 그냥 게으른 A
  trait Future[A] {
    def get: A
    def get(timeout: Long, unit: Timeunit): A
    def cancel(evenIfRunning: Boolean): Boolean
    def isDone: Boolean
    def isCancelled: Boolean
  }
  ```
- `ExecutorService::submit` 메서드는
  - 주어진 `Callable` 값(스칼라에서는 그냥 `submit`에 대한 게으른 인수)에 대응되는
  - 필요에 따라 **개별 스레드**에서 실행할 계산을 처리해주는
    - `Future` 객체를 돌려줌
- 계산의 결과는 `Future`의 `get`메서드로 얻을 수 있음
  - 이 메서드는 결과가 준비될 때까지 현재 스레드의 실행 차단
- `Future`는 또한 **계산의 취소**를 위한 **추가적인 기능**(일정 시간 동안 차단 후 예외를 던지는 등)도 제공
- `run` 함수가 `ExecutorService`에 접근할 수 있다고 가정하고,
  - 그것이 `Par`의 표현을 선택하는 데 어떤 통찰을 접근하는지 확인
    ```scala
    def run[A](s: ExecutorService)(a: Par[A]): A
    ```
- `Par[A]`의 표현으로 사용할 수 있는 가장 간단한 모형은 `ExecutorService => A`
- 이 표현을 선택한다면, `run`을 구현하기가 매우 쉬우나
  - 계산 완료까지의 `대기 시간`이나 `취소 여부`를 `run`의 호출자가 결정할 수 있게 하면 더 좋을 것
- 이를 위해 `Par[A]`를 `ExecutorService => Future[A]`로 두고
  - `run`은 `Future`를 돌려주게 변경
  ```scala
  type Par[A] = ExecutorService => Future[A]
  def run[A](s: ExecutorService)(a: Par[A]): Future[A] = a(s)
  ```
- `Par`가 `ExecutorService`를 필요로 하는 **하나의 함수**로 표현되었기 때문에
  - `Future`의 생성은 이 `ExecutorService`가 제공되기 전까지 일어나지 않음

## 7.3. API의 정련
- 지금까지의 작업 방식은 다소 **작위적**
- 실무에서는 API 설계와 **표현 선택 사이의 경계**가 지금만큼 명확하지 않음
- 표현에 대한 착안이 API 설계 개선에 도움이 되기도 하고,
  - API의 특성이 표현의 선택에 힌트가 되기도 함
- 두 관점 사이를 **유동적**으로 오가면서
  - 질문이 제기되면
  - 원형을 만들어 **실험**을 수행해보는 식으로 진행하는 것이 자연스러움
- `primitive`들을 정의하고, **적절한 정의**를 부여
- 지금까지 개발한 API 함수들을 구현하기
  - `Par`에 대한 표현이 정해졌기 때문에 그리 어렵지 않은 과정

#### CODE.7.5. Par의 기본적인 구현
```scala
object Par {
  // unit은 UnitFuture를 돌려주는 함수로 표현
  // UnitFuture는 Future의 단순한 구현으로, 단순 상수 값을 감싸기만 할 뿐
  // ExecutorService는 전혀 사용하지 않음
  // UnitFuture는 항상 완료 가능하며 취소는 불가능
  // UnitFuture::get 메서드는 이전에 주어진 상수 값을 돌려주기만 함
  def unit[A](a: A): Par[A] = (es: ExecutorService) => UnitFuture(a)

  private case class UnitFuture[A](get: A) extends Future[A] {
    def isDone = true
    def get(timeout: Long, units: TimeUnit) = get
    def isCancelled = false
    def cancel(evenIfRunning:Boolean): Boolean = false
  }

  // 이 API에서 병렬성 제어는 오직 `fork`함수만 담당한다는 설계상의 선택에 따라
  // map2는 f 호출을 논리적 스레드에서 평가하지 않음
  // f를 개별 스레드에서 평가하고 싶다면 fork(map2(a,b,)(f))를 사용하면 됨 
  def map2[A,B,C](a: Par[A], b: Par[B])(f: (A,B) => C): Par[C] =
    (es: ExecutorService) => {
      val af = a(es)
      val bf = b(es)
      UnitFuture(f(af.get, bf.get))
      // map2의 구현은 `만료 시간`을 지키지 않음
      // 이 구현은 ExecutorService를 두 Par 값에 전달하고
      // Future의 af와 bf의 결과들을 기다리고
      // 그것들을 f에 적용
      // 적용 결과를 UnitFuture로 감싼다
      // 만료 시간을 지키기 위해서는
      // af의 평가에 걸린 시간을 측정하고
      // bf의 평가에 걸린 시간에서
      // 그 시간을 빼는 식의, 새로운 Future 구현이 필요
    }
  
  def fork[A](a: => Par[A]): Par[A] =
    es => es.submit(new Callable[A] {
      def call = a(es).get
    })
  /**
    * 이것이 fork의 가장 간단하고 자연스러운 구현
    * 단 몇가지 문제점 존재
    * 외곽의 Callable은 `안쪽 과제가 완료될 때까지 차단`
    * 이러한 차단이, 스레드 풀의 한 스레드(또는 ExecutorService 내부에서 쓰이는 어떤 자원)을 점유하여
    * 이는 `잠재적 병렬성의 일부 소실`을 의미
    * 본질적으로 이 구현은, 한 스레드로 충분한 작업을 `두 스레드로 나누어 수행`
    * 이는 이 구현의 좀 더 심각한 문제점의 증상
    **/
}
```
- `Future` 인터페이스가 **순수 함수적**이지는 않음
  - 이는 이 예제 라이브러리의 사용자가
  - `Future`를 직접 다루게 하는 것이 **바람직하지 않은 이유**의 일부
- 중요한 것은, 이 `Future`의 메서드들이 **부수 효과**에 의존하긴 하지만
  - `Par API` 자체는 여전히 **순수**함
- `Future` 내부 동작 방식은, 오직 사용자가 `run`을 호출해서
  - 구현이 `ExecutorService`를 받게 되어야 드러남
- 구현이 언젠가는 **효과**들에 의존하긴 하지만,
  - 사용자는 항상 **순수한 인터페이스**로 프로그램을 짤 수 있음
- `API`가 순수하므로, 그 효과들은 사실상 **부수 효과가 아님**

#### 암묵적 변환을 이용한 중위 구문 추가
- `Par`가 실제 자료 형식이라면,
  - `map2` 같은 함수를 **클래스 본문**에 두고
  - `x.map2(y)(f)` 같은 **중위 구문**으로 호출 가능
    - `Stream`이나 `Option`에나 했던 것과 동일한 방식
- 그러나 `Par`는 형식 별칭이므로, 직접적으로 그렇게 할 수 없음
- `implicit conversion`을 이용해 **임의의 형식**에 중위 구문을 추가하는 요령이 존재
- 여기서는 다루지 않음

### 기존 조합기의 확장
- 구체적인 예시
  - 하나의 `List[Int]`를 산출하는 병렬 계산을 나타내는 
    - `Par[List[Int]]`가 있다고 가정
  - 이것을 **결과가 정렬된** `Par[List[Int]]`로 변환하고자 함
- 코드
  ```scala
  def sortPart(parList: Par[List[Int]]): Par[List[Int]]
  ```
- 물론 `Par`에 `run`을 적용하고, 결과 목록을 정렬하고
  - 정렬된 목록을 `unit`을 이요해서 다시 `Par`로 꾸밀 수 있음
- 우리는 `run`의 호출을 피하고자 함
- `unit`외에 `Par`의 값을 어떤 방식으로 조작할 수 있는 **조합기**는 `map2`뿐이라 가정
- 그렇다면, 만일 `ParList`를 `map2`의 양변 중 하나에 지정한다면,
  - `List` 내부에 접근해서 목록을 **졍렬**할 수 있음
- `map2`의 다른 변에는 아무것이나 넣어도 되므로, 그냥 `no-op`을 전달하기로 함
  ```scala
  def sortPar(parList: Part[List[Int]]): Par[List[Int]] =
    map2(parList, unit(()))((a, _) => a.sorted)
  ```

### 일반화
- `A => B` 형식의 **임의의 함수**를
  - `Par[A]`를 받고 `Par[B]`를 돌려주는 함수로 **승급**(`lift`)할 수 있음
- 코드
  ```scala
  def map2[A,B](pa: Par[A])(f: A => B): Par[B] =
    map2(pa, unit(()))((a, _) => f(a))

  // sortPar의 정의
  def sortPar(parList: Par[List[Int]]) = map(parList)(_.sorted)
  ```

### map 구현의 중요한 의미
- `map2`가 **둘째 인수**를 그냥 무시하게 만들기 위해
  - 둘째 인수에 무의미한 값 `unit(())`을 넘긴건 아님
- `map2`를 이용하여 `map`을 구현할 수 있지만
  - **그 반대로는 불가능**
  - `map2`가 `map`보다 강력함
- 실제 설계시, **기본 수단**이라고 생각한 함수를
  - 다른 좀 더 **근본적인 기본 수단**들도 표현할 수 있음을 깨닫는 일이 자주 생김

### 또다른 구현
- 하나의 목록에 `map`을 **병렬**로 적용할 수 있을지
- `map2`처럼 두 개의 벙렬 계산을 **결합**하는 것이 아니라,
  - `N`개의 **병렬 계산**을 결합하는 함수 제작
- `parMap`이라는 이름으로 구성
  ```scala
  def parMap[A,B](ps: List[A])(f: A => B): Par[List[B]]
  ```
- `parMap`을 그냥 새로운 **기본 수단**으로 작성도 가능
- `Par[A]`는 `ExecutorService => Future[A]`의 별칭
- 어떠한 연산을 **새로운 기본 수단**으로 구현하는 것은 잘못된 일은 아님
- 경우에 따라, 다루고자 하는 **자료 형식**의 바탕 표현에 관한
  - 어떤 가정을 두면 연산을 좀 더 효율적으로 구현 가능
- 그러나 지금, 우리의 관심은
  - **기존의 API**로 표현할 수 있는 연산을 살펴보고
  - 지금까지 정의한 **여러 연산**들 사이의 **관계**를 파악
- 진정으로 기본적인 **조합기**들을 이해하는 것은
  - 여러 라이브러리에 존재하는 **공통의 패턴**을 **추상화**하는 방법을 다루는 **제3부**에서 더 중요
- `parMap`을 **기존 조합기**를 이용하여 구현하기
  ```scala
  def parMap[A,B](ps: List[A])(f: A => B): Par[List[B]] = {
    val fbs: List[Par[B]] = ps.map(asyncF(f))
    ...
  }
  ```
- `asyncF`가 **병렬 계산**하나를 **분기**(forking)해서 결과를 산출함으로써,
  - `A => B`를 `A => Par[B]`로 변환함을 기억
- 이를 활용하면 `N`개의 **병렬 계산**을 수월하게 분기시킬 수 있음
  - 단, 그 계산들의 **결과를 취합할 방법 필요**
- 형식들을 살펴보면, `List[Par[B]]`를 `parMap`의 반환 형식이 요구하는
  - `Par[List[B]]`로 변환하는 수단이 필요함
- `sequence`를 구현했다면, `parMap`의 구현을 완성할 수 있음
  ```scala
  def parMap[A,B](ps: List[A])(f: A => B): Par[List[B]] = fork {
    val fbs: List[Par[B]] = ps.map(asyncF(f))
    sequence(fbs)
  }

  def sequence[A](ps: List[Par[A]]): Par[List[A]]
  ```
- 구현을 `fork`하나로 감싼 형태
- 이 구현에서 `parMap`은
  - 입력이 **거대한 목록**이라도, 즉시 반환
- 이후 `run`을 호출하면, 하나의 **비동기 계산**이 분기되며,
  - 그 계산은 `N`개의 **병렬 계산**을 띄우고
  - 그 계산들이 끝나길 기다렸다가, **하나의 목록**으로 취합
- 위 `API`로 할 수 있는 것들
  - 목록의 요소들을 병렬로 걸러내는 `parFilter`
    ```scala
    def parFilter[A](as: List[A])(f: A => Boolean): Par[List[A]]
    ```
  - **병렬 합산 함수**를 더 일반화하기
    - `IndexedSeq`의 최댓값을 **병렬**로 찾기
  - `paragraph`의 목록(`List[String]`)을 받고
    - 모든 문단의 **전체 단어 수**를 돌려주는 함수
  - `map3, map4, map5`를 `map2`를 이용해 구현

## 7.4. API의 대수
- 원하는 연산의 형식 서명만 작성한 후
  - `그 형식을 따라가다 보면`
  - 구현에 도달하는 경우가 많음
- 위와 같이 하게되면
  - 구체적인 문제 영역을 완전히 잊어버리고 형식들이 잘 맞아떨어지게 하는데에만 집중 가능
  - `map`을 `map2`와 `unit`으로 구현할 때
- 대수 방정식을 단순화할 때 하는 **추론**과 비슷한 자연스러운 추론 방식
- 이런 떄 우리는 API를 하나의 **대수**(algebra)
  - 즉 일단의 법칙(law) 또는
  - 참이라는 가정하는 속성(property)들을 가진 **추상적인 연산 집합**
  - 그 대수에 정의된 규칙에 따라
    - 형식적으로 기호를 조작하면서 문제를 풀어나감
- API를 다소 **비공식적**으로 추론
  - API가 준수하리라 기대하는 또는 준수하게 만들고자 하는
  - 법칙을 공식화해 보면 유용함

### 7.4.1. map에 관한 법칙
- 법칙의 선택에는 결과(consequence)가 따름
- 일단 법칙을 선택하면
  - 연산에 부여할 수 있는 의미에 제약이 생기고,
  - 선택 가능한 **구현 방식**이 결정되며,
    - 참일 수 있는 **다른 속성**들에도 영향을 미침
- 그럴듯한 법칙 하나 구상
  - 라이브러리를 위한 **검사 코드**를 작성할 때
  - 하나의 **검례**로 사용할만한 코드
    ```scala
    map(unit(1))(_ + _1) == unit(2)
    ```
    - `unit(1)`에 `(_ + 1)` 함수를 사상한 것이, `unit(2)`와 동일함을 의미
  - 법칙은 위와 같이 `identity`(항등식)으로부터 시작하는 경우가 흔함
- 어떤 의미에서 동등할까?
  - 현재는, `임의의 유효한` `ExcutorService`에 대해
  - 두 `Par`객체의 `Future`결과가 서로 같다면
    - 그 두 `Par` 객체가 동등하다고 가정
- 어떤 `ExecutorService`에 대해 이 법칙이 성립하는지는, 다음과 같이 검증 가능
  ```scala
  def equal[A](e: ExecutorService)(p: Par[A], p2: Par[A]): Boolean =
    p(e).get == p2(e).get
  ```
- **법칙**과 **함수**는 공통점이 많음
  - 함수가 일반화가 가능하듯이, **법칙도 일반화 가능**
- 위 법칙을 일반화
  ```scala
  map(unit(x))(f) == unit(f(x))
  ```
  - 이는 이 법칙이 `1`과 `_ + 1`함수 뿐만 아니라
  - `any`(임의)의 `x`와 `f`에 대해 성립함을 의미
- 위 내용은 구현에 **일정한 제약**일 가함
  - 예시로 `unit`을 구현할 때, `unit`은 주어진 입력을 조사하여
  - 그 값이 `1`이면 병렬 계산의 결과로 `42`를 산출하도록 구현할 수 없음
  - `unit`은 단순히, 자신이 받은 것을 넘겨주어야 함
    - `ExecutorService`도 마찬가지
  - `Callable` 객체들의 실행을 위해 제출시,
    - 자신이 받은 값에 대해 `어떠한 가정을 두거나`
      - 그 값에 기초해서 **행동 방식 변경 불가**
    - 이 법칙은 `map`과 `unit`의 구현에서
      - `down casting`이나 `isInstanceOf` 점검(형식 캐스팅, typecasting)
        - 등을 허용하지 않음
- 어떤 함수를 정의할 때, 그보다 더 간단한 함수
  - 즉, 한 가지 일만 하는 함수들을 이용해서 정의하는 것과 유사하게
  - 어떤 법칙을 정의할 때는
    - 한 가지 사실만 **말하는** 더 간단한 **법칙**을 통해 정의 가능
  - 그럴 경우, 법칙을 더 단순하게 만들 수 있는지 확인 가능
- 이 법칙이 임의의 `x`와 `f`에 대해 성립했으면 한다고 가정
  - `f`를 항등 함수(`identify function`)으로 치환하면 흥미로움
  - 등호의 양변을 단순화 하면 아래와 같은 결과 도출 가능
    ```scala
    map(unit(x))(f) == unit(f(x)) // 초기 법칙
    map(unit(x))(id) == unit(id(x)) // `f`를 항등 함수로 치환
    map(unit(x))(id) == unit(x) // 단순화
    map(y)(id) == y // 양변에서 `unit(x) -> y`로 치환
    ```
- 위 간단한 법칙은 오직 `map`에서만 가능
- `unit`의 언급은 군더더기 였음
- 새 법칙의 의미를 더 깊게 파악하기 위해
  - `map`이 할 수 없는 것을 정의
- `map`은 함수의 결과에 적용하기 전에
  - 예외를 던지고 계산을 망치지는 못함
  - `map`은 단지 함수 `f`와 `y`의 결과에 적용할 뿐
- `f`가 `id`라면,
  - `y`에 아무런 영향도 미치지 않음
- `map(y)(id) == y`라고 할 때,
  - 반대 방향의 치환들을 통해서
  - 원래의 더 복잡한 법칙으로 회귀 가능
- 논리적으로, 그러한 ***자유도**는
  - `map`이 주어진 함수에 따라 **다른 방식으로 행동하지 않기 때문**
- 즉, `map(y)(id) == y`라면
  - 반드시 `map(unit(x))(f) == unit(f(x))`도 참이어야 함
- `map`의 매개변수성(`parametricity`) 덕분에
  - 이 2차 법칙 또는 정리가 **공짜**로 생겼다는 점에서
  - 이를 `free theorem`이라고 부르기도 함

### 7.4.2. fork에 관한 법칙
- `fork`가 **병렬 계싼**의 결과에 영향을 미치지 말아야 함
  ```scala
  fork(x) == x
  ```
- 이전의 구현이 이 속성을 실제로 만족함은 **명백**
- `fork`의 작동 방식에 대한 우리의 기대와 부합하는 속성
- `fork(x)`는 `x`와 동일한 일을 수행하되
  - 주 스레드와는 **개별적인 논리적 스레드**에서 **비동기적**으로 수행해야 함
- 이 법칙이 성립하지 않는다면
  - 의미의 변경 없이 `fork`를 안전하게 호출할 수 있는 상황을
  - **형식 시스템**의 도움을 전혀 받지 않고 알아내는 수단을 찾아내야 함
- 위 간단한 속성은 `fork`의 구현을 강하게 제한
- 구현자의 관점을 버리고 **디버거**의 관점에서 법칙을 위반해보기
  - 구석진 경우들을 최대한 찾고 **반례**(countexample)을 생각하면서 법칙이 깨지는 경우를 찾기
  - 이 법칙이 성립함을 **비공식적**으로라도 증명하기
  - 적어도 회의적인 프로그래머를 납득시킬 수 있을 정도의 **증명**은 구축할 수 있음

## 7.4.3. 법칙 깨기: 미묘한 버그 하나
- 디버거의 관점에서 법칙 깨기
- 모든 `x`와 `ExecutorService`에 대해 `fork(x) == x`라고 기대
- `x`로 적합한 것은 `fork`나 `unit`, `map2`와 그를 활용한 **조합기**를 이용한 어떤 **표현식**
- `ExecutorService`는 어떨지 고민 필요
- 이를 구현하는 방법에 대한 고민 필요
- `java.util.concurrent.Executors`에 여러 **구현**들이 나열되어 있음

### 코드에 관한 법칙과 증명이 중요한 이유
- **API**에 관한 **속성**들을 언급하고 **증명**하는 것이 어색할 수 있음
  - 보통의 프로그래밍에서 하는 일은 아님
  - FP에서 중요한 이유가 있음
- FP에서는 **공통의 기능성**을 추출하고 **합성**(composition)을 통해
  - 재사용 가능한 **일반적 구성요소**를 만들기 쉬우며, 당연시 됨
- **부수 효과**는 **합성 능력을 해침**
- 구성요소(func or not)를 **black box**로 취합하지 못하게 만드는
  - 숨겨진 또는 부차적인 가정이 존재할 경우, 합성이 어렵거나 **불가능**함
- `fork`에 관한 법칙의 예에서, 그 법칙이 성립하지 않는다면
  - `parMap`과 같은 **여러 범용 조합기**를 더 이상 유효하지 않게 됨을 알 수 있음
    - 그리고 그 용법이 위험해질 수 있음
    - 조합기가 쓰일만한 넓은 범위의 **병렬 계산**에서는 `deadlock`이 생길수도 있기 때문
- API에 의미 있고 **추론**에 도움이 되는 **법칙**들을 갖춘 **대수**를 부여하면
  - C가 API를 더 잘 활용 가능
- API의 작성자가 API의 객체들을 **black box**로 취급하는 것이 가능
- 이는 우리가 작성한 서로 다른 라이브러리들에 존재하는 **공통의 패턴**을 추출하는데 꼭 필요한 요인

### fork의 구현에서 발생하는 대부분의 문제
- 내부적으로 **고정된 크기**의 스레드 풀을 사용하는 `ExecutorService`의 구현(`Executors.newFixedThreadPool`)
  - `deadlock`에 빠지기 쉬움
- `ExecutorService`가 사용하는 스레드 풀의 `max threads=1`일때, 다음의 코드 수행
  ```scala
  // 대부분의 구현에서 deadlock에 빠짐
  val a = lazyUnit(42 + 1)
  val S = Executors.newFixedThreadPool(1)
  println(Par.equals(S)(a, fork(a)))

  def fork[A](a: => Par[A]): Par[A] =
    es => es.submit(new Callable[A] {
      def call = a(es).get // 다른 Callable 안에 있는 한 Callable의 결과를 기다림
    })
  ```
- 위 코드는 먼저 `Callable`을 제출하고
  - 그 `Callable`안에서 또 다른 `Callable`을 `ExecutorService`에 제출
- 그러면 그 결과가 나올때까지 실행이 차단됨
  - `a(es)`가 `Callable`을 `ExecutorService`에 제출하고, `Future`를 받음
- 만일 `size(threadPool)=1`이면 문제 발생
- 바깥쪽 `Callable`이 제출되면, 스레드풀의 **유일한 스레드**가 할당
- 하지만 스레드는 또 다른 `Callable`을 제출하고, 그 결과를 기다림
- 이미 `Callable`을 실행할 스레드가 남지 않으므로, 서로 기다리며 `deadlock`이 발생
- 위와 같은 반례가 있다면, 선택은 두가지
  - 법칙이 성립하도록 **구현**을 고쳐보는 것
  - 법칙이 성립하는 조건들을 더 **명시적**으로 밝히도록 법칙을 정련하는 것
    - `e.g. threadPool이 무한히 자랄 수 있다는 조건 추가 등`
- 이전에는 **암묵적**으로 존재했던 **불변식**(invariant)이나 가정을
  - 명시적으로 문서화하게 만든다는 점에서, 좋은 훈련이 됨
- **고정 크기 스레드풀**에 잘 작동하도록 `fork`를 수정하려면 다른 구현 필요
  ```scala
  def fork[A](fa: => Par[A]): Par[A] =
    es => fa(es)

  // 계산의 인스턴스화를 실제로 필요한 시점까지 미룸, 위 구현의 이름 변경
  def delay[A](fa: => Par[A]): Par[A] =
    es => fa(es)
  ```
- 위와 같이 작성시, **교착이 방지됨**
- 유일한 문제점은
  - 실제로 **개별적인 논리적 스레드**를 띄워서 `fa`를 평가하지는 않음
- 어떤 `ExecutorService es`에 대해
  - `fork(hugeComputation)(es)`는
  - 주 스레드에서 `hugeComputation`을 실행
  - 애초에 `fork`의 호출로 피하고자 했던 그 상황
- 이 `fork`의 구현도 여전히 좋은 조합기
  - 계산의 인스턴스화를 **실제로 필요한 시점**까지 미루는 용도로 유용하게 사용가능하기 때문
  - `delay`로 명칭 변경
- 우리가 원했던 것은
  - 임의의 계산을 **고정 크기 스레드 풀**로 돌리는 것
- `Par`를 다른 방식으로 구현해야 함

## 7.4.4. 행위자를 이용한 완전 비차단 Par 구현
- **고정 크기 스레드 풀**로도 잘 작동하며
  - 전혀 차단되지 않는(fully non-blocking, 완전비차단) 방식의 `Par` 구현 개발
- 현재 표현의 본질적인 문제
  - `Future::get`을 호출하지 않고서는, `Future`의 값을 꺼낼 수 없음
  - 그 메서드를 호출하면 `현재 스레드`의 실행이 **차단**됨
- `Par`의 표현이 이런식으로 `자원을 흘리지 않도록`하려면
  - **비차단**(non-blocking) 방식이어야 함
- **비차단**은
  - `fork`와 `map2`의 구현이 **현재 스레드를 차단 하는 메서드**(`e.g. Future.get`)을
  - 절대로 호출하지 말아야 함
- 법칙을 만족할 수 있도록 **한 번만** 제대로 구현하면 됨
  - 일단 검사를 통과한다면, 라이브러리 사용자들은 항상 **정확한 결과**를 내는
  - 합성 가능한 **추상 API**를 즐길 수 있음

### 기본 착안
- `Par`의 **비차단 표현**을 하려면
- `Par`를 `java.util.concurrent.Future`로 바꾸어
  - 값을 **꺼내는**(이에 의해 차단이 발생하는) 대신,
  - **적당한 때에 호출되는 콜백을 등록할 수 있는** `Future`를 도입하기
    - 관점의 전환
- 코드
  ```scala
  sealed trait Future[A] {
    // fpinscala.parallelism 패키지의 private 멤버
    // 오직 그 패키지 안의 코드에서만 이 메서드 접근 가능
    private[parallelism] def apply(k: A => Unit): Unit
  }
  // 이전과 동일한 모습이나, `java.util.concurrent`것이 아닌, 직접 만든 Future를 사용
  type Par[+A] = ExecutorService => Future[A]
  ```
- 새로운 `Future API`는 `java.util.concurrent`와 다름
- 이전의 `Future`는 `get`메서드를 제공했지만,
  - 새 `Future`는 `A` 형식의 결과를 산출하는 함수 `k`를 받고
  - 그 결과를 이용해서 어떤 효과를 수행하는 `apply` 메서드를 제공
  - 이런 종류의 함수를 **계속 함수**(continuation)또는 **콜백**(callback)이라고 부름
- `apply` 메서드에는 `private[parallelism]`이 지정되어 있음
  - 이 메서드는 라이브러리 사용자에게 노출되지 않음
  - `fpinscala.parallelism` 패키지 안에서만 접근 가능
  - `API`의 **순수성**을 유지하며, 법칙들의 성립이 보장됨

#### 순수 API에 국소 부수 효과 사용
- 지금 정의한 `Future`의 형식은 **다소 명령식**(imperative)
- `A => Unit`
  - 반환된 결과를 사용하지 않음
  - 함수는 주어진 `A`를 이용하여, 어떤 **효과를 수행**할 때만 유용
- `Future`같은 형식을 사용하면 **함수형 프로그래밍**에서 벗어나는것은 아님
- **부수 효과**를 **순수 함수적 API**의 **구현 세부사항**으로 사용한다는
  - 일반적인 기법을 적용한 것
- 해당 부수 효과들이 `Par`를 사용하는 사용자에게는 **보이지 않기** 때문
- `Future.apply`는 **보호되는 메서드**이므로
  - 외부 코드에서 호출이 전혀 불가
- 비차단 Par 구현의 나머지 부분을 보면
  - **외부 코드**에서는 **부수 효과**를 관찰할 수 없음
- **국소 효과**(local effect; 지역 효과), **관찰 가능성**(observability),
  - **순수성**과 **참조 투명성**등의 미묘한 사항은 `CHAP.14`에서 논의

#### run함수의 구현
- `run`은 그냥 `A`를 돌려주는 형태
- `Par[A]`를 받고 `A`를 돌려주므로,
  - **콜백 함수**를 만들어서 `Future.apply`메서드에 전달할 필요가 있음

##### CODE.7.6. Par를 위한 run의 구현
```scala
def run[A](es: ExecutorService)(p: Par[A]): A = {
  // 결과를 저장하는 데 사용할, 변이가 가능하고 스레드에 안전한 참조
  // java.util.concurrent.atomic 패키지 참고
  val ref = new AtomicReference[A]

  // java.util.concurrent.CountDownLatch를 이용하면
  // countDown 메서드가 일정 횟수만큼 호출될 때까지
  // 스레드를 대기시킬 수 있음
  // countDown 메서드는 p로부터 A형식의 값을 받을 때 한 번 호출
  // run의 구현은 그때까지 차단되어야 함
  val latch = new CountDownLatch(1)

  // 값을 받았으면, 결과를 설정하고 latch을 푸는 형태
  p(es) {
    a => ref.set(a);
    latch.countDown
  }
  // 결과가 준비될때까지 기다렸다가, latch를 품
  latch.await
  // latch를 통과했다면, ref가 설정된 것. 이 값을 반환
  ref.get
}
```
- `latch`가 풀리길 기다리는 동안 `run`을 호출한 스레드가 **차단**됨
- 차단되지 않도록 `run`을 구현하는 것은 불가능
- 이 함수는 `A`형식의 값을 돌려주어야 하므로,
  - 그 값이 준비되길 기다려야 함
- 이 때문에 이 `API의 사용자`는 결과를 기다릴 수 있음이 확실한 때에만 `run`을 호출해야 함
- `API`에서 `run`을 아예 제거하고,
  - 대신 `Par`에 대한 `apply`메서드를 노출해서
  - 사용자가 **비동기 콜백**을 등록하게 만들 수 있음
  - 이 방법은 유효한 설계상 선택이겠으나, 현재는 이 형태로 유지
- `Par`를 실제로 생성하는 예시: `unit`함수
  ```scala
  def unit[A](a: A): Par[A] =
    es => new Future[A] {
      def apply(cb: A => Unit): Unit = 
        // 값을 콜백 함수에 전달, ExecutorService는 필요하지 않음
        cb(a)
    }
  ```
- `unit`은 이미 사용할 수 있는 `A`형식의 값을 가지고 있으므로,
  - 그냥 그 값을 전달해서 **콜백 함수** `cb`를 호출하면 됨
- 만일 그 콜백 함수가 우리의 `run`의 구현에서 비롯된 것이라면
  - 그 호출에 의해 `latch`가 풀려 결과가 즉시 마련됨
- `fork`의 예시: 실제 병렬성 도입
  ```scala
  def fork[A](a: => Par[A]): Par[A] =
    es => new Future[A] {
      def apply(cb: A => Unit):Unit = 
        // eval은 의 평가를 위한 작업을 띄운 후, 즉시 반환
        // 콜백은 이후 다른 스레드에서 비동기적으로 호출
        eval(es)(a(es)(cb))
    }
  
  // 어떤 ExecutorService를 이용해서 계산을 비동기적으로 평가하기 위한 보조 함수
  def eval(es: ExecutorService)(r: => Unit):Unit =
    es.submit(new Callable[Unit] { def call = r })
  ```
- `fork`가 돌려준 `Future`라는 이름으로 전달된
  - 인수 `a`의 평가를 위한 작업을 띄움
- 그 작업은 `a`를 실제로 평가, 호출해서 하나의 `Future[A]`를 산출하며,
- 그 `Future`가 결과 `A`를 산출했을 때, 
  - 호출될 콜백 함수 `cb`(`Future` 호출시 인수로 주어진)을 등록