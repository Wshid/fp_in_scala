# [CHAP.04] 예외를 이용하지 않은 오류 처리
- **예외**를 던지는 것이 하나의 **부수 효과**
- **함수적 코드**에서 **예외**를 사용하지 않는다면,
  - 그 대신 무엇을 사용할까?
- 오류를 **함수적**으로 제기하고, 처리하는데 필요한 **기본 원리**에 대해
- **실패 상황**과 **예외**를 **보통의 값**으로 표현할 수 있으며
  - 일반적인 **오류 처리/복구 패턴**을 추상화한 **고차 함수**를 사용할 수 있음
- **오류를 값으로 돌려준다는 함수적 해법**
  - 더 안전하고, **참조 투명성**을 유지함
- 고차 함수 덕분에 예외의 주된 이점인 **오류 처리 논리의 통합**(consolidation of error-handling logic)도 유지됨
- 표준 라이브러리의 `Option`과 `Either`를 직접 구성해보기

## 4.1. 예외의 장단점
- 예외가 **참조 투명성**을 해침
  - 함수/메서드가 **함수 외부의 영향을 받지 않음**
  - 함수 인자에만 의존적(입력 콘솔, 파일, 원격 url등에 의존적이지 않음)

### CODE.4.1. 예외를 던지고 받기
```scala
def failingFn(i: Int): Int = {
  val y: Int = throw new Exception("fail!")
  try {
    val x = 42 + 5
    x + y
  }
  catch { case e: Exception => 43}
}
```
- `failingFn`를 호출하면, 예상대로 오류 발생
- `y`가 **참조에 투명하지 않음**
  - `임의의 참조 투명 표현식을, 그것이 지정하는 값으로 치환해도 프로그램의 의미가 변하지 않아야 함`
  - `x + y`의 `y`를 `throw new Exception("fail!")`로 치환하면, 그전과는 완전히 다른결과가 나옴

### 참조 투명성
- 참조에 투명한 표현식의 의미는
  - `context`에 의존하지 않으며
  - 지역적으로 추론할 수 있지만, 참조에 투명하지 않은 표현식의 의미는
    - `context-dependent`하며, 좀 더 **전역의 추론**이 필요하다는 것으로 이해해도 됨
- 예를 들어 `42 + 5`의 의미는
  - **그 표현식**을 포함한 **더 큰 표현식**에 의존하지 않음
  - 이 표현식은 언제나 `47`이라는 값을 리턴함
- 하지만 `throw new Exception("fail")`이라는 표현식은 **문맥에 의존적**
  - `try`블록에 포함되어 있는지, 어떤 `try`블록인지에 따라 달라짐

### 예외의 주된 문제(2)
- **예외는 참조 투명성을 위반하고 문맥 의존성을 도입**
  - **치환 모형**의 간단한 추론이 불가능해지고,
  - **예외**에 기초한 혼란스러운 코드 유발
  - 예외를 **오류 처리**에만 사용하고, **흐름 제어에는 사용하지 말아야 함**
- **예외는 형식에 안전하지 않음**
  - `failingFn`의 형식인 `Int => Int`로는 예외를 던질지 알 수 없음
  - compiler는 `failingFn`의 호출자에게 **그 예외를 처리하는 방식을 결정하라고 강제 불가**
  - 예외 점검 코드를 추가하지 않게 되면, `RunTime`에서야 검출 됨

### 예외 대체 방안
- 기본 장점
  - **오류 처리 논리의 통합과 중앙집중화**를 유지하는 대안이 있으면 좋을 것
    - 오류 처리 논리를 **코드 기반**의 여기 저기에 널어놓지 않아도 되도록 하는 대안
- **예외를 던지는 대신, 예외적인 조건이 발생했음을 뜻하는 값을 돌려준다**라는 오래된 착안에 기초
- `C`에서는 예외 처리를 위해 `error code`를 돌려주는 방법과 유사
  - 단, 오류 부호를 직접 돌려주는 대신, 그런 **미리 정의해 둘 수 있는 값들**을 대표하는 새로운 일반적 형식을 도입하고,
  - 오류의 처리와 전파에 관한 **공통적인 패턴**들을 고차 함수들을 이용해 캡슐화
- `C` 스타일의 **오류 부호**와는 달리
  - **형식에 완전히 안전**하며
  - 최소한의 구문적 잡음으로도 스칼라의 **형식 점검기**의 도움을 받아 **실수를 미리 발견하는 것**

### 점검된 예외
- `Java`의 `checked exception`은 적어도 오류를 **처리할 것인지, 다시 발생시킬 것인지** 결정을 강제
  - 결과적으로 호출하는 쪽에 판에 박힌(**boilerplate**) 코드가 추가됨
- 점검된 예외는 **고차 함수에는 통하지 않음**
- 고차 함수에서는 인수가 구체적으로 **어떤 예외를 던질지 미리 알 수 없음**
- 예시 코드
  ```scala
  def map[A,B](l: List[A])(f: A => B): List[B]
  ```
  - 함수 자체는 일반적임이 명백하나, **점검된 예외**와는 잘 맞지 않음
  - 모든 가능한(`f가 던질 수 있는`) 점검된 예외마다, `map`의 개별적인 버전을 만들수는 없는 일
- `Java`에서도 **일반적 코드**가 `RuntimeException`이나 어떤 공통의 점검된 `Exception` 형식에 의존할 수 밖에 없는 이유

## 4.2. 예외의 가능한 대안들
- 평균을 구하는 함수 예시
  - 빈목록에 대해서 평균이 정의되지 않음
  - 코드
    ```scala
    // Seq : 선형 순차열 비슷한 컬렉션들의 공통 인터페이스
    def mean(xs: Seq[Double]): Double = 
      if (xs.isEmpty)
        throw new ArithmeticException("mean of empty list")
      else xs.sum / xs.length // sum은 순차열의 요소가 수치 형식일 때만 `Seq`의 메서드로 정의됨
      // 표준 lib에서는 implicit 클래스를 이용하여 구현
    ```
- `mean`은 `partial function`의 예시
- **부분 함수**란 **일부 입력**에 대해서는 정의되지 않는 함수를 의미
  - 자신이 받아들이는 입력에 대해
    - **입력 형식**만으로는 결정되지 않는 어떤 **가정을 두는 함수**
- 받아들여지지 않는 상황에 대해 **예외**를 던질 수 있으나, 꼭 그러지 않아도 됨

### mean 함수의 예외의 대안

#### 첫번째 대안
- `Double`형식의 가짜 값을 돌려주는 것
  - 빈 목록에 대해 `0.0/0.0` 연산, `Double.NaN`을 리턴
  - 또는 어떤 경계 값(`sentinel value`)를 돌려줄 수 있음
  - 상황에 따라 `null`로 리턴 가능
- 위 방법을 사용하지 않는 이유
  - **오류의 소리 없는 전파**
    - 어떤 오류 조건의 점검을 빼먹어도, `compiler`가 경고하지 않음
    - 오류의 코드 확인 시점이 늦어짐
  - 호출자가 **진짜 결과**를 받았는지 점검하는 `명시적 if문`으로 구성된 코드가 많아짐
  - 다형적 코드에는 적용 불가
    - 출력 형식에 따라 **경계값을 정할 수 없음**
      - e.g. 리턴값이 `Boolean`인 상황에서, 그 이외에 값 리턴 불가능 등
  - 호출자에게 **특별한 방침**이나 **호출 규약**을 요구
    - `mean`을 제대로 사용하려면, 결과를 받아내는 것 이외의 작업이 수반됨
    - **특별한 방침**이 많아질 수록,
      - 모든 인수를 **균일한 방식**으로 처리해야하는 **고차 함수**에 전달하기 어려워짐

#### 두번째 대안
- 함수가 입력을 처리할 수 없는 상황이 생겼을 때, 무엇을 해야하는지 **인수**를 호출자가 지정하기
- 코드
  ```scala
  def mean_1(xs: IndexedSeq[Double], onEmpty: Double): Double =
    if (xs.isEmpty) onEmpty
    else xs.sum / xs.length
  ```
- `mean`은 `total function`이 됨
- 그러나, **직접적인 호출자**가 이 함수의 처리방식을 알고 있어야 함
  - 그런 경우에도, 항상 하나의 `Double`값을 결과로 돌려주어야 함
- 결국, `정의되지 않는 경우`가 가장 적당한 수준에서 처리되므로,
  - 그 처리 방식의 결정을 미룰 수 있게 해야 함