# [CHAP.04] 예외를 이용하지 않은 오류 처리
- **예외**를 던지는 것이 하나의 **부수 효과**
- **함수적 코드**에서 **예외**를 사용하지 않는다면,
  - 그 대신 무엇을 사용할까?
- 오류를 **함수적**으로 제기하고, 처리하는데 필요한 **기본 원리**에 대해
- **실패 상황**과 **예외**를 **보통의 값**으로 표현할 수 있으며
  - 일반적인 **오류 처리/복구 패턴**을 추상화한 **고차 함수**를 사용할 수 있음
- **오류를 값으로 돌려준다는 함수적 해법**
  - 더 안전하고, **참조 투명성**을 유지함
- 고차 함수 덕분에 예외의 주된 이점인 **오류 처리 논리의 통합**(consolidation of error-handling logic)도 유지됨
- 표준 라이브러리의 `Option`과 `Either`를 직접 구성해보기

## 4.1. 예외의 장단점
- 예외가 **참조 투명성**을 해침
  - 함수/메서드가 **함수 외부의 영향을 받지 않음**
  - 함수 인자에만 의존적(입력 콘솔, 파일, 원격 url등에 의존적이지 않음)

### CODE.4.1. 예외를 던지고 받기
```scala
def failingFn(i: Int): Int = {
  val y: Int = throw new Exception("fail!")
  try {
    val x = 42 + 5
    x + y
  }
  catch { case e: Exception => 43}
}
```
- `failingFn`를 호출하면, 예상대로 오류 발생
- `y`가 **참조에 투명하지 않음**
  - `임의의 참조 투명 표현식을, 그것이 지정하는 값으로 치환해도 프로그램의 의미가 변하지 않아야 함`
  - `x + y`의 `y`를 `throw new Exception("fail!")`로 치환하면, 그전과는 완전히 다른결과가 나옴

### 참조 투명성
- 참조에 투명한 표현식의 의미는
  - `context`에 의존하지 않으며
  - 지역적으로 추론할 수 있지만, 참조에 투명하지 않은 표현식의 의미는
    - `context-dependent`하며, 좀 더 **전역의 추론**이 필요하다는 것으로 이해해도 됨
- 예를 들어 `42 + 5`의 의미는
  - **그 표현식**을 포함한 **더 큰 표현식**에 의존하지 않음
  - 이 표현식은 언제나 `47`이라는 값을 리턴함
- 하지만 `throw new Exception("fail")`이라는 표현식은 **문맥에 의존적**
  - `try`블록에 포함되어 있는지, 어떤 `try`블록인지에 따라 달라짐

### 예외의 주된 문제(2)
- **예외는 참조 투명성을 위반하고 문맥 의존성을 도입**
  - **치환 모형**의 간단한 추론이 불가능해지고,
  - **예외**에 기초한 혼란스러운 코드 유발
  - 예외를 **오류 처리**에만 사용하고, **흐름 제어에는 사용하지 말아야 함**
- **예외는 형식에 안전하지 않음**
  - `failingFn`의 형식인 `Int => Int`로는 예외를 던질지 알 수 없음
  - compiler는 `failingFn`의 호출자에게 **그 예외를 처리하는 방식을 결정하라고 강제 불가**
  - 예외 점검 코드를 추가하지 않게 되면, `RunTime`에서야 검출 됨

### 예외 대체 방안
- 기본 장점
  - **오류 처리 논리의 통합과 중앙집중화**를 유지하는 대안이 있으면 좋을 것
    - 오류 처리 논리를 **코드 기반**의 여기 저기에 널어놓지 않아도 되도록 하는 대안
- **예외를 던지는 대신, 예외적인 조건이 발생했음을 뜻하는 값을 돌려준다**라는 오래된 착안에 기초
- `C`에서는 예외 처리를 위해 `error code`를 돌려주는 방법과 유사
  - 단, 오류 부호를 직접 돌려주는 대신, 그런 **미리 정의해 둘 수 있는 값들**을 대표하는 새로운 일반적 형식을 도입하고,
  - 오류의 처리와 전파에 관한 **공통적인 패턴**들을 고차 함수들을 이용해 캡슐화
- `C` 스타일의 **오류 부호**와는 달리
  - **형식에 완전히 안전**하며
  - 최소한의 구문적 잡음으로도 스칼라의 **형식 점검기**의 도움을 받아 **실수를 미리 발견하는 것**

### 점검된 예외
- `Java`의 `checked exception`은 적어도 오류를 **처리할 것인지, 다시 발생시킬 것인지** 결정을 강제
  - 결과적으로 호출하는 쪽에 판에 박힌(**boilerplate**) 코드가 추가됨
- 점검된 예외는 **고차 함수에는 통하지 않음**
- 고차 함수에서는 인수가 구체적으로 **어떤 예외를 던질지 미리 알 수 없음**
- 예시 코드
  ```scala
  def map[A,B](l: List[A])(f: A => B): List[B]
  ```
  - 함수 자체는 일반적임이 명백하나, **점검된 예외**와는 잘 맞지 않음
  - 모든 가능한(`f가 던질 수 있는`) 점검된 예외마다, `map`의 개별적인 버전을 만들수는 없는 일
- `Java`에서도 **일반적 코드**가 `RuntimeException`이나 어떤 공통의 점검된 `Exception` 형식에 의존할 수 밖에 없는 이유