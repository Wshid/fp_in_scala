# [CHAP.05] 엄격성과 나태성
- **CHAP.03**에서 **단일 연결 목록**의 예로
  - 순수 함수적 자료구조를 논의
- `map, filter, foldLeft, foldRight, zipWith` 등
  - 목록에 대한 일괄 연산 진행
- 이 연산들이 모두 
  - 주어진 **입력 목록 전체**를 훑고
  - 새로운 목록을 **연산의 결과**로 돌려줌
- 한번만 순회하기 => `traversal`
- 예시
  - 놀이용 카드 한 벌에서, 홀수 카드를 모두 제거하고, 퀸 카드를 뒤집기
  - 스칼라는 후자의 방식으로 수행(홀수 카드 모두 제거 후, 남은 카드에서 퀸을 찾음)
    ```scala
    List(1,2,3,4).map(_ + 10).filter(_ % 2 == 0).map(_ * 3)
    ```
    - 각 변환은 자신만의 새로운 목록을 생성함, 그리고 다음 변환의 입력으로만 쓰인후 폐기됨
      - `map(_ + 10)`은 그 자체의 새로운 목록을 생성
      - 이후 `filter`로 넘긴 후, 폐기
- 비엄격성(`non-strictness`), 나태성(`laziness`)를 이용하면
  - 자동적인 **루프 융합**이 가능해짐
- 비엄격성이 **함수적 프로그램**의 **효율성**과 **모듈성**을 개선하는 근본적인 기법

## 5.1. 엄격한 함수와 엄격하지 않은 함수
- **비엄격성**은 함수의 한 속성
- `함수가 엄격하지 않다`
  - 그 함수가 하나 이상의 인수들을 **평가하지 않을 수 있음**
- `함수가 엄격하다`
  - 자신의 **인수**들을 항상 **평가**
  - 대부분의 언어는, 인수들을 모두 평가하는 함수만 지원
  - 스칼라에서도 특별히 다르게 지정하지 않는 한, **모든 함수 정의는 엄격한 함수**
- 예시
  ```scala
  def square(x: Double): Double = x * x

  // 정상 호출
  square(41.0 + 1.0)

  // 비정상 호출, 표현식이 square 본문에 진입하기 전에 평가
  square(sys.error("failure"))
  ```
- 스칼라를 비롯한 여러 프로그래밍 언어에서 `||`, `&&`는 **비엄격**
  - 인수의 평가가 생략될 수도 있는 함수로 생각 가능
- `&&`함수는 `Boolean`인수 두 개를 받되,
  - 첫번째 인수가 `true`일때만 둘째 인수를 평가
- 스칼라 `if 제어 구조`의 비엄격성 예시
  ```scala
  val result = if (input.isEmpty) sys.error("empty input") else input
  ```
  - if의 경우 내장 언어 구조이긴 함
  - `if`함수는 자신의 **모든 인수를 평가하지 않음**적인 측면에서 **비엄격 함수**
  - `if` 함수는 **조건 매개변수**에 대해서는 엄격함
    - 참/거짓에 따른 두 분기를 선택하기 위해, 조건이 평가되어야 하기 때문
  - 단, `true/false` 분기에 대해서는 엄격하지 않음
    - 둘 중 하나만 조건에 따라 평가되기 때문 
- 인수 중, 일부가 평가되지 않아도 호출이 성립하는 비엄격 함수
  - 비엄격 `if`함수 예시
    ```scala
    def if2[A](cond:Boolean, onTrue: () => A, onFalse: () => A):A = 
        if (cond) onTrue() else onFalse()
    
    if2(a <22,
        () => println("a"), // () => A 를 생성하는 리터럴 구문
        () => println("b")
    )
    ```
    - `평가되지 않을 채 전달될 인수`에는 해당 형식 바로 앞에 `() =>`를 표기해준다
      - `() => A`는 인수를 받지 않고 `A`를 돌려주는 함수
    - 일반적으로 표현식의 **평가되지 않은 상태**를 `thunk`라고 함
    - 나중에 그 `thunk`의 표현식을 평가하여, 결과를 내보내도록 **강제** 가능
      - `onTrue`나 `onFalse`처럼 **빈 인수 목록**을 지정하여 함수를 호출하면 됨
    - `if2`의 호출자는 `thunk`를 명시적으로 생성해야 함
      - 함수 리터럴 구문의 것과 동일한 관례를 따름
- 비엄격 `if`를 더 깔끔하게 표현하기
  ```scala
  def if2[A](cond:Boolean, onTrue: => A, onFalse => A):A =
    if (cond) onTrue else onFalse

  if2(false, sys.error("fail"), 3)
  ```
  - 평가되지 않은 채로 전달할 인수에는, 그 형식 앞에 `=>`만 붙이는 형태
  - `=>`는 함수 본문에서 지정된 인수를 평가하는데 **어떤 특별한 구문도 필요하지 않음**
    - 평소대로 식별자만 참조하면 됨
  - 함수를 호출할때도, 별다른 구문이 필요하지 않으며
    - 보통의 함수 구문만 사용하면 `thunk`내의 표현식을 알아서 감싸줌
- 평가되지 않은 채로 전달되는 인수는
  - 함수의 본문에서 **참조된 장소마다 한 번씩 평가됨**
  - 스칼라는 인수 평가의 결과를 기본적으로 **캐싱하지 않음**
    ```scala
    def maybeTwice(b:Boolean, i: => Int) = if (b) i+i else 0
    val x = maybeTwice(true, { println("hi"); 1+41})
    // "hi"가 두 번 호출됨, 84 반환

    // 캐싱이 적용된, lazy하게 평가하기
    def maybeTwice2(b: Boolean, i:=> Int) = {
        lazy val j = i
        if (b) j+j else 0
    }
    val x = maybeTwice2(true, { println("hi"); 1+41})
    // "hi"가 한번 호출됨, 84 반환
    ```
- `lazy val`을 사용하게 되면,
  - 우변의 평가를, 우변이 **처음 참조될 때까지 지연**
  - **평가 결과를 캐시에** 담아주고, 이후 참조에서는 **평가를 되풀이 하지 않음**
- 스칼라에서의 **비엄격 함수**의 인수는
  - **값**(by value)으로 전달되는 것이 아닌 **이름**(by name)으로 전달 됨

### 엄격성의 공식적인 정의
- `어떤 표현식의 평가가 무한정 실행`되거나, `한정된 값을 돌려주지 않고 오류`를 던진다면,
  - 그러한 표현식을 `terminate`하지 않는 표현식 또는 `bottom`으로 평가되는 표현식이라 부름
- 만일 **바닥**으로 평가되는 모든 `x`에 대해 표현식 `f(x)`가 바닥으로 평가되면,
  - 그러한 함수 `f`는 **엄격한** 함수이다