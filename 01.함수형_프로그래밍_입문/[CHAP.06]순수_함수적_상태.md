# [CHAP.06] 순수 함수적 상태
- `state`를 다루는 순수 함수적 프로그램 작성 방법
  - 난수 발생 분야의 예시를 통해 확인
- 임의의 상태 있는(stateful) API를 **순수 함수적**으로 만드는 데 쓰이는 기본 패턴을 익히기

## 6.1. 부후 효과를 이용한 난수 발생
- `scala`에서 난수 생성시 `scala.util.Random` 클래스를 이용
- 위 클래스는 **부수 효과**에 의존하는 상당히 전형적인 **명령식**(imperastive) API를 제공
- 예시
  ```scala
  // 시스템 시간을 seed로 하여 새 난수 발생기 생성
  val rng = new scala.util.Random
  rng.nextDouble
  rng.nextInt
  rng.nextInt(10) // 0 ~ 9 이하의 정수 난수
  ```
- 상태 갱신은 **부수 효과**로서 수행되므로
  - 이 메서서들은 **참조**에 투명하지 않음
- 참조에 투명하지 않은 함수는 `그렇지 않은 함수`에 비해
  - `검사, 합성, 모듈화가 어려움`
  - `병렬화 어려움`
- **검사성**을 확인해보기
- **무작위성**을 활용하는 메서드를 작성할 때는
  - 그런 메서드의 **재현성**(repoducibility)를 검사할 필요가 있음
- 예시 : 육면체 주사위, `1~6`의 정수를 돌려주는 메서드
  ```scala
  def rollDie: Int = {
    val rng = new scala.util.Random
    rng.nextInt(6) // 0 ~ 5
  }
  ```
  - `off-by-one error`가 존재
  - `1 ~ 6`의 값을 돌려주어야 하나, 실제로는 `0 ~ 5`의 값을 반환
  - 명세대로 작동하지 않지만, `5/6`의 확률로 통과 함
  - 검사에 **실패**했을 때는, 실패 상황을 신뢰성 있게 재현할 수 있다면 **이상적**
- 위와 같은 간단한 예시가 아닌, 메서드가 훨씬 복잡하고, 버그가 훨씬 미묘한 상황도 얼마든지 상상 가능
- 위 예시의 해결책은, 난수 발생기를 인수로 전달하는 방법
  - 그렇게 되면, **실패한 검사 재현**시, 그 때 쓰였던 동일한 **난수 발생기**를 전달하면 됨
    ```scala
    val rollDie(rng: scal.util.Random):Int = rng.nextInt(6)
    ```
  - 단 **동일한** 발생기의 경우 `seed`와 기타 **내부 상태**가 동일해야 함
    - **상태가 동일**하다는 것은
      - 발생기를 만든 이후, 그 메서드들이 **원래의 발생기 메서드 호출 횟수**와 동일하게 호출되었음을 의미
    - 하지만 이를 보장하기는 매우 어려움
      - `nextInt`를 호출할 때마다, 난수 발생기의 **이전 상태가 파괴됨**
    - `Random` 메서드가 몇 번 호출되었는지 추적하는 **개별적인 매커니즘**을 마련해야 할까?
      - 그렇지 않음, 단 **부수 효과를 피해야하 함**

## 6.2. 순수 함수적 난수 발생
- **참조 투명성**을 되찾는 관건은
  - **상태 갱신**을 **명시적**으로 드러냄
- 상태를 **부수 효과**로서 갱신하지 말고
  - 그냥 새 상태를 **발생한 난수**와 함께 돌려주면 됨
- 예시 : 난수 발생기의 인터페이스
  ```scala
  trait RNG {
    def nextInt: (Int, RNG)
  }
  ``` 
  - 위 메서드는 무작위 `Int`를 생성해야 함
  - 이 `nextInt`를 이용해서, 다른 함수도 정의해야 함
  - 발생한 난수만 돌려주고, 내부 상태는 **제자리**(in-place)변이를 통해서 갱신하는 대신,
    - 이 인터페이스는 **난수**와 **새 상태**를 돌려주고, 기존 상태는 수정하지 않음
- 다음 상태를 **계산**하는 관심사와
  - 새 상태를 프로그램 나머지 부분에 **알려주는** 관심사를 분리함
- **전역 변이 가능 메모리**는 전혀 쓰이지 않음
- 그냥 다음 상태를 호출자에게 돌려줄 뿐
- 이 API의 사용자가
  - **난수 발생기의 자체 구현**에 대해서는 아무것도 모른다는 점에서,
  - 여전히 발생기 안에 **캡슐화**되어 있음을 의미
- 난수 발생기의 구현 방법
  - 기존에는 여러 방법이 있으나,
  - `scala.util.Random`과 같은 알고리즘을 사용하는 간단한 난수 발생기
  - 이는 **선형 합동 발생기**(Linear congruential generator)
  - `nextInt`가 발생된 난수와, 새 `RNG`객체를 돌려줌
    - `RNG`객체 : 다음 값을 생성하는데 사용

### CODE.6.2. 순수 함수적 난수 발생기
- 코드
  ```scala
  case class SimpleRNG(seed: Long) extends RNG {
    def nextInt: (Int, RNG) = {
      val newSeed = (seed * 0x5DEECE66DL + 0xBL) & 0xFFFFFFFFFFFFL // 비트곱 논리 연산(&), 현재 seed를 기준으로 새로운 seed 생성
      val nextRNG = SimpleRNG(newSeed) // 다음 상태(새 seed로 생성한 RNG Instance)
      val n (newSeed >>> 16).nextInt // >>>는 빈자리를 0으로 채우는, 이진 오른쪽 자리 이동. n은 새 의사난수 정수
      (n, nextRNG) // 반환값은 의사난수 정수와 다음 발생기 상태를 담은 튜플
    }
  }
  ```
- `SimpleRNG` 실행 예시
  ```scala
  val rng = SimpleRNG(42) // 임의의 seed=42
  val (n1, rng2) = rng.nextInt
  val (n2, rng3) = rng2.nextInt
  ```
  - 위 예시를 여러번 되풀이해서 실행해도 **항상 같은 값**을 반환
    - 이 API는 **순수**하다